{"ast":null,"code":"import _slicedToArray from\"/Users/stephensheldon/Documents/Coding/React/react-router-portfolio/router-portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from\"react\";function useOnScreen(ref){var threshold=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0.3;// State and setter for storing whether element is visible\nvar _useState=useState(false),_useState2=_slicedToArray(_useState,2),isIntersecting=_useState2[0],setIntersecting=_useState2[1];useEffect(function(){var observer=new IntersectionObserver(function(_ref){var _entry$isIntersecting;var _ref2=_slicedToArray(_ref,1),entry=_ref2[0];// Update our state when observer callback fires\nsetIntersecting((_entry$isIntersecting=entry===null||entry===void 0?void 0:entry.isIntersecting)!==null&&_entry$isIntersecting!==void 0?_entry$isIntersecting:false);},{rootMargin:\"0px\",threshold:threshold});var currentRef=ref.current;if(currentRef){observer.observe(currentRef);}return function(){if(currentRef){observer.unobserve(currentRef);}};},[ref,threshold]);// Empty array ensures that effect is only run on mount and unmount\nreturn isIntersecting;}export default useOnScreen;","map":{"version":3,"sources":["/Users/stephensheldon/Documents/Coding/React/react-router-portfolio/router-portfolio/src/hooks/useOnScreen.js"],"names":["useState","useEffect","useOnScreen","ref","threshold","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","rootMargin","currentRef","current","observe","unobserve"],"mappings":"2MAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CAEA,QAASC,CAAAA,WAAT,CAAqBC,GAArB,CAA2C,IAAjBC,CAAAA,SAAiB,2DAAL,GAAK,CACzC;AACA,cAA0CJ,QAAQ,CAAC,KAAD,CAAlD,wCAAOK,cAAP,eAAuBC,eAAvB,eAEAL,SAAS,CAAC,UAAM,CACd,GAAMM,CAAAA,QAAQ,CAAG,GAAIC,CAAAA,oBAAJ,CACf,cAAa,4DAAXC,KAAW,UACX;AACAH,eAAe,wBAACG,KAAD,SAACA,KAAD,iBAACA,KAAK,CAAEJ,cAAR,+DAA0B,KAA1B,CAAf,CACD,CAJc,CAKf,CACEK,UAAU,CAAE,KADd,CAEEN,SAAS,CAATA,SAFF,CALe,CAAjB,CAUA,GAAMO,CAAAA,UAAU,CAAGR,GAAG,CAACS,OAAvB,CACA,GAAID,UAAJ,CAAgB,CACdJ,QAAQ,CAACM,OAAT,CAAiBF,UAAjB,EACD,CACD,MAAO,WAAM,CACX,GAAIA,UAAJ,CAAgB,CACdJ,QAAQ,CAACO,SAAT,CAAmBH,UAAnB,EACD,CACF,CAJD,CAKD,CApBQ,CAoBN,CAACR,GAAD,CAAMC,SAAN,CApBM,CAAT,CAoBsB;AAEtB,MAAOC,CAAAA,cAAP,CACD,CACD,cAAeH,CAAAA,WAAf","sourcesContent":["import { useState, useEffect } from \"react\";\n\nfunction useOnScreen(ref, threshold = 0.3) {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry?.isIntersecting ?? false);\n      },\n      {\n        rootMargin: \"0px\",\n        threshold,\n      }\n    );\n    const currentRef = ref.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [ref, threshold]); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}\nexport default useOnScreen;\n"]},"metadata":{},"sourceType":"module"}