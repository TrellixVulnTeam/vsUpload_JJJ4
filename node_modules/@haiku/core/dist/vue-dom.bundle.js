var HaikuVueAdapter = (function () {
'use strict';

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var getParsedProperty_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var HAIKU_CONFIG_PROPS_RENAME_MAPPING = {
    haikuOptions: 'options',
    haikuStates: 'states',
    haikuInitialStates: 'states',
    haikuEventHandlers: 'eventHandlers',
    haikuTimelines: 'timelines',
    haikuVanities: 'vanities',
};
/**
 * Parses a specific property specified by `verboseKeyName` from the `props`
 * object, renaming and merging legacy props as necessary.
 * This method is mainly used by the React and Vue adapters.
 * @param props
 * @param verboseKeyName
 * @returns {Object}
 */
var getParsedProperty = function (props, verboseKeyName) {
    var result = {};
    var haikuConfigRemappedKey = HAIKU_CONFIG_PROPS_RENAME_MAPPING[verboseKeyName];
    var haikuConfigFinalKey = haikuConfigRemappedKey || verboseKeyName;
    // Special case: Options used to be a separate object, so if we see this legacy
    // format, just merge it in with the root level of the new options
    if (haikuConfigFinalKey === 'options') {
        for (var optionsSubKey in props[verboseKeyName]) {
            result[optionsSubKey] = props[verboseKeyName][optionsSubKey];
        }
    }
    else {
        result[haikuConfigFinalKey] = props[verboseKeyName];
    }
    return result;
};
exports.default = getParsedProperty;

});

unwrapExports(getParsedProperty_1);

var StringUtils = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.ALPHABET = 'abcdefghijklmnopqrstuvwxyz';
exports.randomString = function (len) {
    var str = '';
    while (str.length < len) {
        str += exports.ALPHABET[Math.floor(Math.random() * exports.ALPHABET.length)];
    }
    return str;
};

});

unwrapExports(StringUtils);
var StringUtils_1 = StringUtils.ALPHABET;
var StringUtils_2 = StringUtils.randomString;

var HaikuVueDOMAdapter_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var clearProps = function (props) {
    var result = {};
    for (var verboseKeyName in props) {
        if (props[verboseKeyName] === undefined) {
            continue;
        }
        Object.assign(result, getParsedProperty_1.default(props, verboseKeyName));
    }
    return result;
};
var allProps = function (vueComponent) {
    return Object.assign(clearProps(vueComponent.$props), {
        ref: vueComponent.$el,
        onHaikuComponentWillInitialize: function (component) {
            vueComponent.$emit('haikuComponentWillInitialize', component);
        },
        onHaikuComponentDidMount: function (component) {
            vueComponent.$emit('haikuComponentDidMount', component);
        },
        onHaikuComponentWillMount: function (component) {
            vueComponent.$emit('haikuComponentWillMount', component);
        },
        onHaikuComponentDidInitialize: function (component) {
            vueComponent.$emit('haikuComponentDidInitialize', component);
        },
        onHaikuComponentWillUnmount: function (component) {
            vueComponent.$emit('haikuComponentWillUnmount', component);
        },
        children: vueComponent.$slots.default
            ? vueComponent.$slots.default.filter(function (node) { return node.tag !== undefined; })
            : [],
        vanities: {
            'controlFlow.placeholder': function (element, surrogate, value, context, timeline, receiver, sender) {
                if (element.__memory.placeholder.surrogate === surrogate || !element.__memory.targets) {
                    return;
                }
                var node = element.__memory.targets[0];
                if (node) {
                    var vueElement = surrogate.elm;
                    var div = document.createElement('div');
                    node.parentNode.replaceChild(div, node);
                    node.style.visibility = 'hidden';
                    if (vueElement) {
                        div.appendChild(vueElement);
                    }
                    window.requestAnimationFrame(function () {
                        element.__memory.placeholder.surrogate = surrogate;
                        node.style.visibility = 'visible';
                    });
                    sender.markHorizonElement(element);
                    sender.markForFullFlush();
                }
            },
        },
    });
};
// tslint:disable-next-line:function-name
function HaikuVueDOMAdapter(haikuComponentFactory) {
    return {
        props: {
            // We use null (which is the equivalent of 'any') for Boolean values
            // because Vue does typecasting for us, which sets undefined to false.
            automount: null,
            autoplay: null,
            forceFlush: null,
            freeze: null,
            loop: null,
            alwaysComputeSizing: null,
            seed: String,
            sizing: String,
            timestamp: Number,
            frame: Function,
            clock: Object,
            preserve3d: String,
            contextMenu: String,
            position: String,
            overflowX: String,
            overflowY: String,
            overflow: String,
            mixpanel: String,
            interactionMode: Object,
            states: Object,
            eventHandlers: Object,
            timelines: Object,
            vanities: Object,
            children: Array,
            placeholder: Object,
            // LEGACY
            haikuOptions: Object,
        },
        mounted: function () {
            this.haiku = haikuComponentFactory(this.$el, allProps(this));
        },
        updated: function () {
            this.haiku.assignConfig(allProps(this));
        },
        destroyed: function () {
            this.haiku.callUnmount();
        },
        render: function (createElement) {
            return createElement('div', {
                attrs: {
                    id: "haiku-vueroot-" + StringUtils.randomString(24),
                },
                style: {
                    position: 'relative',
                    margin: 0,
                    padding: 0,
                    border: 0,
                    width: '100%',
                    height: '100%',
                    transform: 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)',
                },
            }, this.$slots.default);
        },
    };
}
exports.default = HaikuVueDOMAdapter;

});

unwrapExports(HaikuVueDOMAdapter_1);

var vueDom = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

exports.default = HaikuVueDOMAdapter_1.default;

});

unwrapExports(vueDom);

/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */

var vue = vueDom.default;

return vue;

}());
