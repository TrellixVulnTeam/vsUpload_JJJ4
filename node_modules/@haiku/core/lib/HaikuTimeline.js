"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var HaikuBase_1 = require("./HaikuBase");
var getActionsMaxTime_1 = require("./helpers/getActionsMaxTime");
var getTimelineMaxTime_1 = require("./helpers/getTimelineMaxTime");
var Tokenizer_1 = require("./reflection/Tokenizer");
var assign_1 = require("./vendor/assign");
var NUMBER = 'number';
var DEFAULT_OPTIONS = {
    // loop: Boolean
    // Determines whether this timeline should loop (start at its beginning when finished)
    loop: true,
};
var TimeUnit;
(function (TimeUnit) {
    TimeUnit["Millisecond"] = "ms";
    TimeUnit["Frame"] = "fr";
})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));
var PlaybackFlag;
(function (PlaybackFlag) {
    PlaybackFlag["ONCE"] = "once";
    PlaybackFlag["PLAY"] = "play";
    PlaybackFlag["LOOP"] = "loop";
    PlaybackFlag["STOP"] = "stop";
    PlaybackFlag["SEEK"] = "seek";
})(PlaybackFlag = exports.PlaybackFlag || (exports.PlaybackFlag = {}));
var makePlaybackProc = function (body) {
    // tslint:disable-next-line:no-function-constructor-with-string-args
    return new Function('$time', body);
};
var PLAYBACK_FLAGS = {
    once: true,
    play: true,
    loop: true,
    stop: true,
    seek: true,
};
// tslint:disable:variable-name
var HaikuTimeline = /** @class */ (function (_super) {
    __extends(HaikuTimeline, _super);
    function HaikuTimeline(component, name, options) {
        var _this = _super.call(this) || this;
        _this.component = component;
        _this.name = name;
        _this.assignOptions(options || {});
        _this.globalClockTime = 0;
        _this.localElapsedTime = 0;
        _this.localControlledTime = null; // Only set this to a number if time is 'controlled'
        _this.areUpdatesFrozen = !!_this.options.freeze;
        _this.isTimelineLooping = !!_this.options.loop;
        _this.isTimelinePlaying = true;
        _this.offsetCalculator = null;
        _this.lastFrame = null;
        _this.numLoops = 0;
        return _this;
    }
    HaikuTimeline.prototype.getMs = function (amount, unit) {
        switch (unit) {
            case "fr" /* Frame */:
                return Math.round(this.getFrameDuration() * amount);
            case "ms" /* Millisecond */:
            default:
                // The only currently valid alternative to TimeUnit.Frame is TimeUnit.Millisecond.
                return amount;
        }
    };
    HaikuTimeline.prototype.getFrameDuration = function () {
        return this.component.getClock().getFrameDuration();
    };
    HaikuTimeline.prototype.assignOptions = function (options) {
        this.options = assign_1.default(this.options || {}, DEFAULT_OPTIONS, options || {});
    };
    HaikuTimeline.prototype.ensureClockIsRunning = function () {
        var clock = this.component.getClock();
        if (!clock.isRunning()) {
            clock.start();
        }
    };
    /**
     * @method setComponent
     * @description Internal hook to allow Haiku to hot swap on-stage components during editing.
     */
    HaikuTimeline.prototype.setComponent = function (component) {
        this.component = component;
    };
    HaikuTimeline.prototype.doUpdateWithGlobalClockTime = function (globalClockTime) {
        if (this.isFrozen()) {
            return;
        }
        var prevGlobalClockTime = this.getClockTime();
        var deltaGlobalClockTime = globalClockTime - prevGlobalClockTime;
        this.globalClockTime = globalClockTime;
        // If we update with the global clock time while a timeline is paused, the next
        // time we resume playing it will "jump forward" to the time that has elapsed.
        if (this.isPaused()) {
            return;
        }
        this.doUpdateWithTimeDelta(deltaGlobalClockTime);
    };
    HaikuTimeline.prototype.doUpdateWithTimeDelta = function (deltaClockTime) {
        var ceilTime = this.getCeilTime();
        var prevElapsedTime = this.getElapsedTime();
        var newElapsedTime = prevElapsedTime + deltaClockTime;
        var didLoop = HaikuTimeline.didTimeLoop(prevElapsedTime, newElapsedTime, ceilTime);
        this.setElapsedTime(newElapsedTime);
        // If we are a looping timeline, reset to zero once we've gone past our max
        if (this.isLooping() && didLoop) {
            this.numLoops++;
            // Avoid log DoS for too-short timelines
            if (this.getMaxTime() > 200) {
                this.component.callHook('timeline:loop', {
                    localElapsedTime: newElapsedTime,
                    maxExplicitlyDefinedTime: this.getMaxTime(),
                    globalClockTime: this.getClockTime(),
                    boundedFrame: this.getBoundedFrame(),
                    loopCount: this.numLoops,
                });
            }
        }
    };
    HaikuTimeline.prototype.executePreUpdateHooks = function (globalClockTime) {
        this.doUpdateWithGlobalClockTime(globalClockTime);
    };
    HaikuTimeline.prototype.executePostUpdateHooks = function (globalClockTime) {
        if (this.isFrozen() || this.isPaused()) {
            return;
        }
        var frame = this.getBoundedFrame();
        var time = Math.round(this.getBoundedTime());
        this.component.routeEventToHandlerAndEmitWithoutBubbling(HaikuBase_1.GLOBAL_LISTENER_KEY, "timeline:" + this.getName() + ":" + frame, [frame, time]);
        // Allow users to subscribe to the 'frame' event globally
        this.component.routeEventToHandlerAndEmitWithoutBubbling(HaikuBase_1.GLOBAL_LISTENER_KEY, 'frame', [frame, time]);
        // Deprecated; please use the 'frame' event instead. This is used by the Haiku Share Page.
        this.emit('tick', frame, time);
        this.lastFrame = frame;
    };
    HaikuTimeline.prototype.getLastFrame = function () {
        return this.lastFrame;
    };
    HaikuTimeline.prototype.controlTime = function (controlledTimeToSet, newGlobalClockTime) {
        this.setControlledTime(parseInt(controlledTimeToSet || 0, 10));
        // Need to update the properties so that accessors like .getFrame() work after this update.
        this.doUpdateWithGlobalClockTime(newGlobalClockTime);
    };
    HaikuTimeline.prototype.isTimeControlled = function () {
        return typeof this.getControlledTime() === NUMBER;
    };
    /**
     * @method getName
     * @description Return the name of this timeline
     */
    HaikuTimeline.prototype.getName = function () {
        return this.name;
    };
    /**
     * @method getMaxTime
     * @description Return the maximum time that this timeline will reach, in ms.
     */
    HaikuTimeline.prototype.getMaxTime = function () {
        var _this = this;
        return this.cacheFetch('getMaxTime', function () {
            var descriptorMax = _this.getMaxKeyframeTime();
            var actionsMax = _this.getMaxActionsTime();
            return Math.max(descriptorMax, actionsMax);
        });
    };
    HaikuTimeline.prototype.getMaxKeyframeTime = function () {
        return getTimelineMaxTime_1.default(this.getDescriptor());
    };
    HaikuTimeline.prototype.getMaxActionsTime = function () {
        return Math.round(getActionsMaxTime_1.default(this.name, this.component.bytecode.eventHandlers, this.getFrameDuration()));
    };
    HaikuTimeline.prototype.getDescriptor = function () {
        return this.component.getTimelineDescriptor(this.name);
    };
    /**
     * @description The millisecond value for the beginning of one frame past the max.
     */
    HaikuTimeline.prototype.getCeilTime = function () {
        return this.getMaxTime() + this.getMs(1, "fr" /* Frame */);
    };
    /**
     * @method getClockTime
     * @description fseek the global clock time that this timeline is at, in ms,
     * whether or not our local time matches it or it has exceeded our max.
     * This value is ultimately managed by the clock and passed in.
     */
    HaikuTimeline.prototype.getClockTime = function () {
        return this.globalClockTime;
    };
    /**
     * @method getElapsedTime
     * @description Return the amount of time that has elapsed on this timeline since
     * it started updating, up to the most recent time update it received from the clock.
     * Note that for inactive ftimelines, this value will cease increasing as of the last update.
     */
    HaikuTimeline.prototype.getElapsedTime = function () {
        return this.localElapsedTime;
    };
    HaikuTimeline.prototype.setElapsedTime = function (t) {
        this.localElapsedTime = t;
    };
    /**
     * @description If time has been explicitly set here via time control, this value will
     * be the number of that setting.
     */
    HaikuTimeline.prototype.getControlledTime = function () {
        return this.localControlledTime;
    };
    HaikuTimeline.prototype.setControlledTime = function (t) {
        this.localControlledTime = t;
    };
    /**
     * @description Return the locally elapsed time, or the maximum time of this timeline,
     * whichever is smaller. Useful if you want to know what the "effective" time of this
     * timeline is, not necessarily how much has elapsed in an absolute sense. This is used
     * in the renderer to determine what value to calculate "now" deterministically.
     */
    HaikuTimeline.prototype.getBoundedTime = function () {
        var max = this.getMaxTime();
        var time = (this.isTimeControlled())
            ? this.getControlledTime()
            : this.getElapsedTime();
        if (this.offsetCalculator) {
            try {
                time = this.offsetCalculator.call(this, time);
            }
            catch (exception) {
                // no-op
            }
        }
        if (this.isLooping()) {
            var looped = HaikuTimeline.modulo(Math.round(time), this.getCeilTime());
            return looped;
        }
        // Don't allow negative time
        if (time < 0.000001) {
            time = 0;
        }
        return Math.min(time, max);
    };
    /**
     * @description Convenience wrapper. Currently returns the bounded time. There's an argument
     * that this should return the elapsed time, though. #TODO
     */
    HaikuTimeline.prototype.getTime = function () {
        return this.getBoundedTime();
    };
    /**
     * @description Return the current frame up to the maximum frame available for this timeline's duration.
     */
    HaikuTimeline.prototype.getBoundedFrame = function () {
        var time = this.getTime(); // Returns the bounded time
        var timeStep = this.component.getClock().getFrameDuration();
        return Math.round(time / timeStep);
    };
    /**
     * @method getUnboundedFrame
     * @description Return the current frame, even if it is above the maximum frame.
     */
    HaikuTimeline.prototype.getUnboundedFrame = function () {
        var time = this.getElapsedTime(); // The elapsed time can go larger than the max time; see timeline.js
        var timeStep = this.component.getClock().getFrameDuration();
        return Math.round(time / timeStep);
    };
    /**
     * @method getFrame
     * @description Return the bounded frame.
     * There's an argument that this should return the absolute frame. #TODO
     */
    HaikuTimeline.prototype.getFrame = function () {
        return this.getBoundedFrame();
    };
    /**
     * @method isPlaying
     * @description Returns T/F if the timeline is playing
     */
    HaikuTimeline.prototype.isPlaying = function () {
        return this.isTimelinePlaying;
    };
    HaikuTimeline.prototype.setPlaying = function (isPlaying) {
        if (isPlaying === void 0) { isPlaying = true; }
        this.isTimelinePlaying = !!isPlaying;
    };
    HaikuTimeline.prototype.isPaused = function () {
        return !this.isPlaying();
    };
    /**
     * @method isFinished
     * @description Returns T/F if the timeline is finished.
     * If this timeline is set to loop, it is never "finished".
     */
    HaikuTimeline.prototype.isFinished = function () {
        if (this.isLooping() || this.isTimeControlled()) {
            return false;
        }
        return this.getElapsedTime() > this.getMaxTime();
    };
    HaikuTimeline.prototype.isUnfinished = function () {
        return !this.isFinished();
    };
    HaikuTimeline.prototype.getDuration = function () {
        return this.getMaxTime() || 0;
    };
    HaikuTimeline.prototype.setRepeat = function (bool) {
        if (bool === void 0) { bool = true; }
        this.isTimelineLooping = !!bool;
    };
    HaikuTimeline.prototype.getRepeat = function () {
        return this.isTimelineLooping;
    };
    HaikuTimeline.prototype.isRepeating = function () {
        return this.getRepeat();
    };
    HaikuTimeline.prototype.isLooping = function () {
        return this.isRepeating();
    };
    /**
     * @method isFrozen
     * @description Returns T/F if the timeline is frozen
     */
    HaikuTimeline.prototype.isFrozen = function () {
        return this.areUpdatesFrozen;
    };
    HaikuTimeline.prototype.freeze = function () {
        this.areUpdatesFrozen = true;
    };
    HaikuTimeline.prototype.unfreeze = function () {
        this.areUpdatesFrozen = false;
    };
    HaikuTimeline.prototype.start = function () {
        this.startSoftly(0);
        this.emit('start');
    };
    HaikuTimeline.prototype.startSoftly = function (maybeElapsedTime) {
        this.setPlaying(true);
        this.setElapsedTime(maybeElapsedTime || 0);
    };
    HaikuTimeline.prototype.stop = function () {
        this.stopSoftly();
        this.emit('stop');
    };
    HaikuTimeline.prototype.stopSoftly = function () {
        this.setPlaying(false);
    };
    HaikuTimeline.prototype.pause = function () {
        this.pauseSoftly();
        this.emit('pause');
    };
    HaikuTimeline.prototype.pauseSoftly = function () {
        this.setPlaying(false);
    };
    HaikuTimeline.prototype.play = function (options) {
        if (options === void 0) { options = {}; }
        this.playSoftly();
        if (!options || !options.skipMarkForFullFlush) {
            this.component.markForFullFlush();
        }
        this.emit('play');
    };
    HaikuTimeline.prototype.playSoftly = function () {
        this.ensureClockIsRunning();
        this.setPlaying(true);
        // When playing after exiting controlled-time mode, start from the last controlled time.
        if (this.isTimeControlled()) {
            this.setElapsedTime(this.getControlledTime());
            // To properly exit controlled-time mode, we need to set controlled time to null.
            this.setControlledTime(null);
        }
    };
    HaikuTimeline.prototype.seek = function (amount, unit) {
        if (unit === void 0) { unit = "fr" /* Frame */; }
        var ms = this.getMs(amount, unit);
        this.seekSoftly(ms);
        this.component.markForFullFlush();
        this.emit('seek', ms);
    };
    HaikuTimeline.prototype.seekSoftly = function (ms) {
        this.ensureClockIsRunning();
        this.controlTime(ms, this.component.getClock().getTime());
        this.setElapsedTime(this.getControlledTime());
    };
    HaikuTimeline.prototype.gotoAndPlay = function (amount, unit) {
        if (unit === void 0) { unit = "fr" /* Frame */; }
        var ms = this.getMs(amount, unit);
        this.seekSoftly(ms);
        this.play(null);
    };
    HaikuTimeline.prototype.gotoAndStop = function (amount, unit) {
        if (unit === void 0) { unit = "fr" /* Frame */; }
        this.seekSoftly(this.getMs(amount, unit));
        if (this.component && this.component.context && this.component.context.tick) {
            this.component.context.tick();
        }
        this.pause();
    };
    HaikuTimeline.prototype.setPlaybackStatus = function (input) {
        var _a = this.parsePlaybackStatus(input), flag = _a.flag, time = _a.time, proc = _a.proc;
        if (flag === "loop" /* LOOP */) {
            this.setRepeat(true);
        }
        if (flag === "once" /* ONCE */) {
            this.setRepeat(false);
        }
        // If the sending timeline is frozen, don't inadvertently unfreeze its component's guests
        if (flag === "loop" /* LOOP */ || // In the current API, loop also connotes play
            flag === "once" /* ONCE */ ||
            flag === "play" /* PLAY */) {
            if (!this.isPlaying()) {
                this.play();
            }
        }
        if (flag === "stop" /* STOP */) {
            if (this.isPlaying()) {
                this.stop();
            }
        }
        if (flag === "seek" /* SEEK */) {
            this.seek(time || 0, "ms" /* Millisecond */);
        }
        if (typeof proc === 'function') {
            this.offsetCalculator = proc;
        }
    };
    HaikuTimeline.prototype.parsePlaybackStatus = function (input) {
        if (!input) {
            return {
                flag: "loop" /* LOOP */,
            };
        }
        // If an object, assume it takes the format of a flag payload
        if (typeof input === 'object') {
            return input;
        }
        if (typeof input === 'number' && Tokenizer_1.isNumeric(input)) {
            return {
                flag: "seek" /* SEEK */,
                // Assume the input is frames and convert to our internal format, milliseconds
                time: this.getMs(Number(input), "fr" /* Frame */),
            };
        }
        if (typeof input === 'string') {
            var tokens = this.cacheFetch("getPlaybackStatusTokens:" + input, function () {
                return Tokenizer_1.tokenizeDirective(input).map(function (_a) {
                    var value = _a.value;
                    return value;
                });
            });
            // If no tokens, assume the default: A looping timeline
            if (tokens.length < 1) {
                return {
                    flag: "loop" /* LOOP */,
                };
            }
            // Fast-path if we got a single playback flag string
            if (tokens.length === 1 && PLAYBACK_FLAGS[tokens[0]]) {
                return {
                    flag: tokens[0],
                };
            }
            var finals = [];
            // Convert any known number-unit tuples in the token stream into their canonical
            // ms-based time value. For example [100,ms]->[100], or [10]->[166] (frames to ms).
            for (var i = 0; i < tokens.length; i++) {
                var curr = tokens[i];
                var next = tokens[i + 1];
                if (typeof curr === 'number') {
                    if (next === 'ms') {
                        finals.push(this.getMs(curr, "ms" /* Millisecond */));
                        i++;
                        continue;
                    }
                    if (next === 'fr') {
                        finals.push(this.getMs(curr, "fr" /* Frame */));
                        i++;
                        continue;
                    }
                    // Frames are assumed to be the default that an end-user would write
                    if (next !== 'fr') {
                        finals.push(this.getMs(curr, "fr" /* Frame */));
                        continue;
                    }
                }
                finals.push(curr);
            }
            if (finals.length > 1) {
                // E.g. if we got +100, make it loop+100
                if (!PLAYBACK_FLAGS[finals[0]]) {
                    finals.unshift("loop" /* LOOP */);
                }
            }
            var expr = finals.map(function (val) {
                if (PLAYBACK_FLAGS[val]) {
                    return '$time';
                }
                return val;
            }).join(' ');
            var proc = void 0;
            try {
                proc = makePlaybackProc("return " + expr + ";");
            }
            catch (exception) {
                // no-op
            }
            var out = {
                proc: proc,
                flag: finals[0],
            };
            return out;
        }
        return {
            flag: "loop" /* LOOP */,
        };
    };
    /**
     * @deprecated
     * TODO: Please change this to a getter.
     */
    HaikuTimeline.prototype.duration = function () {
        return this.getDuration();
    };
    Object.defineProperty(HaikuTimeline.prototype, "repeat", {
        get: function () {
            return this.getRepeat();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuTimeline.prototype, "time", {
        get: function () {
            return this.getTime();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuTimeline.prototype, "max", {
        get: function () {
            return this.getMaxTime();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuTimeline.prototype, "frame", {
        get: function () {
            return this.getFrame();
        },
        enumerable: true,
        configurable: true
    });
    HaikuTimeline.__name__ = 'HaikuTimeline';
    HaikuTimeline.all = function () { return HaikuBase_1.default.getRegistryForClass(HaikuTimeline); };
    HaikuTimeline.where = function (criteria) {
        var all = HaikuTimeline.all();
        return all.filter(function (timeline) {
            return timeline.matchesCriteria(criteria);
        });
    };
    HaikuTimeline.create = function (component, name, config) {
        return new HaikuTimeline(component, name, config);
    };
    /**
     * @description Modulus, but returns zero if the second number is zero,
     * and calculates an appropriate "cycle" if the number is negative.
     */
    HaikuTimeline.modulo = function (n, ceil) {
        if (ceil === 0) {
            return 0;
        }
        return ((n % ceil) + ceil) % ceil;
    };
    /**
     * @description Given a previous elapsed time (a), a new elapsed time (b), and a max
     * time (max), determine whether the given timeline has looped between (a) and (b).
     *
     * E.g.:
     *   0----------100
     *        62        103  true
     *
     *   0----------100
     *        62    100  true
     *
     *   0----------100
     *        62   99  false
     *
     *   0----------100
     *              100  110  false
     *
     *   0----------100
     *               101  110  false
     *
     *   0----------100
     *              100
     *              100  false
     *
     *   0----------100
     *   0          100  false
     *
     *   0----------100
     *   0
     *   0  false
     */
    HaikuTimeline.didTimeLoop = function (a, b, ceil) {
        var ma = HaikuTimeline.modulo(a, ceil);
        var mb = HaikuTimeline.modulo(b, ceil);
        return mb < ma;
    };
    return HaikuTimeline;
}(HaikuBase_1.default));
exports.default = HaikuTimeline;
//# sourceMappingURL=HaikuTimeline.js.map