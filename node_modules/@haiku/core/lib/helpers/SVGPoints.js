"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var svg_points_1 = require("../vendor/svg-points");
var parseCssValueString_1 = require("./parseCssValueString");
// In leiu of good math, this gives pretty good results for converting arcs to cubic beziers
var MAGIC_BEZIER_ARC_RATIO = 1.8106602;
var SVG_TYPES = {
    g: true,
    rect: true,
    polyline: true,
    polygon: true,
    path: true,
    line: true,
    ellipse: true,
    circle: true,
};
var SVG_POINT_NUMERIC_FIELDS = {
    cx: true,
    cy: true,
    r: true,
    rx: true,
    ry: true,
    x1: true,
    x2: true,
    x: true,
    y: true,
};
var SVG_POINT_COMMAND_FIELDS = {
    d: true,
    points: true,
};
var SVG_COMMAND_TYPES = {
    path: true,
    polyline: true,
    polygon: true,
};
function polyPointsStringToPoints(pointsString) {
    if (!pointsString) {
        return [];
    }
    if (Array.isArray(pointsString)) {
        return pointsString;
    }
    // Normalize "x1,y1 x2,y2" syntax to "x1 y1 x2 y2" syntax before splitting.
    var chunkedPoints = [];
    var points = pointsString.trim().replace(/,/g, ' ').split(/\s+/g).map(Number);
    for (var i = 0; i < points.length; i += 2) {
        chunkedPoints.push(points.slice(i, i + 2));
    }
    return chunkedPoints;
}
function pointsToPolyString(points) {
    if (!points) {
        return '';
    }
    if (typeof points === 'string') {
        return points;
    }
    var arr = [];
    for (var i = 0; i < points.length; i++) {
        var point = points[i];
        var seg = point.join(',');
        arr.push(seg);
    }
    return arr.join(' ');
}
function rectToPoints(x, y, width, height, rxIn, ryIn) {
    var rx = rxIn;
    var ry = ryIn;
    if (rx || ry) {
        if (rx && isNaN(ry)) {
            ry = rx;
        } // Assume equal radius if ry is not defined (SVG)
        if (isNaN(rx)) {
            rx = 0;
        }
        if (isNaN(ry)) {
            ry = 0;
        }
        return [
            {
                y: y,
                x: x + rx,
                moveTo: true,
            },
            {
                y: y,
                x: x + width - rx,
            },
            {
                x: x + width,
                y: y + ry,
                curve: {
                    type: 'cubic',
                    x1: x + width - rx + rx / MAGIC_BEZIER_ARC_RATIO,
                    y1: y,
                    x2: x + width,
                    y2: y + ry / MAGIC_BEZIER_ARC_RATIO,
                },
            },
            {
                x: x + width,
                y: y + height - ry,
            },
            {
                x: x + width - rx,
                y: y + height,
                curve: {
                    type: 'cubic',
                    x1: x + width,
                    y1: y + height - ry / MAGIC_BEZIER_ARC_RATIO,
                    x2: x + width - rx + rx / MAGIC_BEZIER_ARC_RATIO,
                    y2: y + height,
                },
            },
            {
                x: x + rx,
                y: y + height,
            },
            {
                x: x,
                y: y + height - ry,
                curve: {
                    type: 'cubic',
                    x1: x + rx - rx / MAGIC_BEZIER_ARC_RATIO,
                    y1: y + height,
                    x2: x,
                    y2: y + height - ry / MAGIC_BEZIER_ARC_RATIO,
                },
            },
            {
                x: x,
                y: y + ry,
            },
            {
                y: y,
                x: x + rx,
                closed: true,
                curve: {
                    type: 'cubic',
                    x1: x,
                    y1: y + ry - ry / MAGIC_BEZIER_ARC_RATIO,
                    x2: x + rx - rx / MAGIC_BEZIER_ARC_RATIO,
                    y2: y,
                },
            },
        ];
    }
    // Non-rounded rect
    return [
        {
            x: x,
            y: y,
            moveTo: true,
        },
        {
            y: y,
            x: x + width,
        },
        {
            x: x + width,
            y: y + height,
        },
        {
            x: x,
            y: y + height,
            closed: true,
        },
        {
            x: x,
            y: y,
        },
    ];
}
function circleToPoints(cx, cy, r) {
    return ellipseToPoints(cx, cy, r, r);
}
function ellipseToPoints(cx, cy, rx, ry) {
    return [
        {
            x: cx,
            y: cy - ry,
            moveTo: true,
        },
        {
            x: cx + rx,
            y: cy,
            curve: {
                type: 'cubic',
                x1: cx + rx / MAGIC_BEZIER_ARC_RATIO,
                y1: cy - ry,
                x2: cx + rx,
                y2: cy - ry / MAGIC_BEZIER_ARC_RATIO,
            },
        },
        {
            x: cx,
            y: cy + ry,
            curve: {
                type: 'cubic',
                x1: cx + rx,
                y1: cy + ry / MAGIC_BEZIER_ARC_RATIO,
                x2: cx + rx / MAGIC_BEZIER_ARC_RATIO,
                y2: cy + ry,
            },
        },
        {
            x: cx - rx,
            y: cy,
            curve: {
                type: 'cubic',
                x1: cx - rx / MAGIC_BEZIER_ARC_RATIO,
                y1: cy + ry,
                x2: cx - rx,
                y2: cy + ry / MAGIC_BEZIER_ARC_RATIO,
            },
        },
        {
            x: cx,
            y: cy - ry,
            closed: true,
            curve: {
                type: 'cubic',
                x1: cx - rx,
                y1: cy - ry / MAGIC_BEZIER_ARC_RATIO,
                x2: cx - rx / MAGIC_BEZIER_ARC_RATIO,
                y2: cy - ry,
            },
        },
    ];
}
function lineToPoints(x1, y1, x2, y2) {
    var shape = { x1: x1, y1: y1, x2: x2, y2: y2, type: 'line' };
    return svg_points_1.default.toPoints(shape);
}
function pathToPoints(pathString) {
    if (!pathString) {
        return [];
    }
    var shape = { type: 'path', d: pathString };
    return svg_points_1.default.toPoints(shape);
}
function pointsToPath(pointsArray) {
    return svg_points_1.default.toPath(pointsArray);
}
function manaToPoints(mana) {
    if (typeof mana.elementName === 'string' &&
        SVG_TYPES[mana.elementName] &&
        mana.elementName !== 'rect' &&
        mana.elementName !== 'g') {
        var shape = { type: mana.elementName };
        if (SVG_COMMAND_TYPES[shape.type]) {
            for (var f2 in SVG_POINT_COMMAND_FIELDS) {
                if (mana.attributes[f2]) {
                    shape[f2] = mana.attributes[f2];
                }
            }
        }
        else {
            for (var f1 in SVG_POINT_NUMERIC_FIELDS) {
                if (mana.attributes[f1]) {
                    shape[f1] = Number(mana.attributes[f1]);
                }
            }
        }
        return svg_points_1.default.toPoints(shape);
    }
    // div, rect, svg ...
    var width = parseCssValueString_1.default((mana.layout &&
        mana.layout.computed &&
        mana.layout.computed.size &&
        mana.layout.computed.size.x) ||
        (mana.rect && mana.rect.width) ||
        (mana.attributes &&
            mana.attributes.style &&
            mana.attributes.style.width) ||
        (mana.attributes && mana.attributes.width) ||
        (mana.attributes && mana.attributes.x) ||
        0, null).value;
    var height = parseCssValueString_1.default((mana.layout &&
        mana.layout.computed &&
        mana.layout.computed.size &&
        mana.layout.computed.size.y) ||
        (mana.rect && mana.rect.height) ||
        (mana.attributes &&
            mana.attributes.style &&
            mana.attributes.style.height) ||
        (mana.attributes && mana.attributes.height) ||
        (mana.attributes && mana.attributes.y) ||
        0, null).value;
    var left = parseCssValueString_1.default((mana.rect && mana.rect.left) ||
        (mana.attributes.style && mana.attributes.style.left) ||
        mana.attributes.x ||
        0, null).value;
    var top = parseCssValueString_1.default((mana.rect && mana.rect.top) ||
        (mana.attributes.style && mana.attributes.style.top) ||
        mana.attributes.y ||
        0, null).value;
    return svg_points_1.default.toPoints({
        width: width,
        height: height,
        type: 'rect',
        x: left,
        y: top,
    });
}
exports.default = {
    rectToPoints: rectToPoints,
    circleToPoints: circleToPoints,
    ellipseToPoints: ellipseToPoints,
    lineToPoints: lineToPoints,
    pathToPoints: pathToPoints,
    pointsToPath: pointsToPath,
    polyPointsStringToPoints: polyPointsStringToPoints,
    pointsToPolyString: pointsToPolyString,
    manaToPoints: manaToPoints,
};
//# sourceMappingURL=SVGPoints.js.map