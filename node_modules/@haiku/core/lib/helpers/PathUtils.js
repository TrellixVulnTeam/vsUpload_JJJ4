"use strict";
/* tslint:disable:max-line-length */
Object.defineProperty(exports, "__esModule", { value: true });
var SVGPathReversal_1 = require("../vendor/svg-path-reversal/SVGPathReversal");
var SVGPoints_1 = require("./SVGPoints");
exports.splitSegmentInSVGPoints = function (points, pt1Index, pt2Index, t) {
    if (pt2Index === points.length) {
        // tslint:disable-next-line
        pt2Index = 0;
    }
    var h1;
    var h2;
    if (points[pt2Index].curve) {
        h1 = { x: points[pt2Index].curve.x1, y: points[pt2Index].curve.y1 };
        h2 = { x: points[pt2Index].curve.x2, y: points[pt2Index].curve.y2 };
    }
    else {
        h1 = points[pt1Index];
        h2 = points[pt2Index];
    }
    var newPts = exports.cubicBezierSplit(t, points[pt1Index], h1, h2, points[pt2Index]);
    if (points[pt2Index].curve) {
        points[pt2Index].curve.x1 = newPts[1][1].x;
        points[pt2Index].curve.y1 = newPts[1][1].y;
        points[pt2Index].curve.x2 = newPts[1][2].x;
        points[pt2Index].curve.y2 = newPts[1][2].y;
    }
    var newCurve = null;
    if (points[pt2Index].curve) {
        newCurve = {
            type: 'cubic',
            x1: newPts[0][1].x,
            y1: newPts[0][1].y,
            x2: newPts[0][2].x,
            y2: newPts[0][2].y,
        };
    }
    var newPoint = {
        x: newPts[0][3].x,
        y: newPts[0][3].y,
        curve: newCurve,
    };
    points.splice(pt2Index, 0, newPoint);
};
// NOTE: See Bezier curve splitting here: https://pomax.github.io/bezierinfo/#matrixsplit
exports.cubicBezierSplit = function (t, anchor1, handle1, handle2, anchor2) {
    var cubicSegmentMatrix1 = [
        1,
        0,
        0,
        0,
        -(t - 1),
        t,
        0,
        0,
        Math.pow(t - 1, 2),
        -2 * t * (t - 1),
        t * t,
        0,
        -Math.pow(t - 1, 3),
        3 * t * Math.pow(t - 1, 2),
        -3 * t * t * (t - 1),
        t * t * t,
    ];
    var x1 = exports.mat4_multiply_vec4(cubicSegmentMatrix1, { x: anchor1.x, y: handle1.x, z: handle2.x, w: anchor2.x });
    var y1 = exports.mat4_multiply_vec4(cubicSegmentMatrix1, { x: anchor1.y, y: handle1.y, z: handle2.y, w: anchor2.y });
    var cubicSegmentMatrix2 = [
        -Math.pow(t - 1, 3),
        3 * t * Math.pow(t - 1, 2),
        -3 * t * t * (t - 1),
        t * t * t,
        0,
        Math.pow(t - 1, 2),
        -2 * t * (t - 1),
        t * t,
        0,
        0,
        -(t - 1),
        t,
        0,
        0,
        0,
        1,
    ];
    var x2 = exports.mat4_multiply_vec4(cubicSegmentMatrix2, { x: anchor1.x, y: handle1.x, z: handle2.x, w: anchor2.x });
    var y2 = exports.mat4_multiply_vec4(cubicSegmentMatrix2, { x: anchor1.y, y: handle1.y, z: handle2.y, w: anchor2.y });
    return [
        [{ x: x1.x, y: y1.x }, { x: x1.y, y: y1.y }, { x: x1.z, y: y1.z }, { x: x1.w, y: y1.w }],
        [{ x: x2.x, y: y2.x }, { x: x2.y, y: y2.y }, { x: x2.z, y: y2.z }, { x: x2.w, y: y2.w }],
    ];
};
exports.distance = function (a, b) {
    return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
};
// tslint:disable-next-line:variable-name
exports.mat4_multiply_vec4 = function (m, v) {
    return {
        x: v.x * m[0] + v.y * m[1] + v.z * m[2] + v.w * m[3],
        y: v.x * m[4] + v.y * m[5] + v.z * m[6] + v.w * m[7],
        z: v.x * m[8] + v.y * m[9] + v.z * m[10] + v.w * m[11],
        w: v.x * m[12] + v.y * m[13] + v.z * m[14] + v.w * m[15],
    };
};
exports.polygonArea = function (points) {
    var area = 0;
    var a;
    var b = points[points.length - 1];
    for (var i = 0; i < points.length; i++) {
        a = b;
        b = points[i];
        area += a.y * b.x - a.x * b.y;
    }
    return area / 2;
};
exports.polygonLength = function (points) {
    var perimeter = 0;
    var a;
    var b = points[points.length - 1];
    for (var i = 0; i < points.length; i++) {
        a = b;
        b = points[i];
        perimeter += exports.distance(a, b);
    }
    return perimeter;
};
exports.distributeTotalVertices = function (path, totalVertices) {
    var pointsToAdd = totalVertices - path.length;
    if (pointsToAdd <= 0) {
        return;
    }
    // Find the length of every segment (approximate)
    // NOTE: This computes distance across the vertices, not along the actual bezier curve.
    // A possible improvement would be finding true distance along the curve, but at a much
    // higher computational cost.
    var segments = [];
    for (var i = 0; i < path.length; i++) {
        segments.push({
            index: i,
            length: exports.distance(path[i], path[(i + 1) % path.length]),
            splits: 0,
        });
    }
    var addedPoints = 0;
    while (addedPoints < pointsToAdd) {
        // Sort by length, accounting for number of splits
        segments.sort(function (a, b) { return (a.length / (a.splits || 1) - b.length / (b.splits || 1)); });
        // Split the longest segment again
        segments[segments.length - 1].splits++;
        addedPoints++;
    }
    // Apply the splits
    segments.sort(function (a, b) { return (a.index - b.index); });
    var inserted = 0;
    for (var i = 0; i < segments.length; i++) {
        while (segments[i].splits > 0) {
            // NOTE: This splits at linear values for t
            // A possible improvement would be finding truly equidistant points along the curve
            // at much higher computational cost.
            exports.splitSegmentInSVGPoints(path, i + inserted, (i + inserted + 1) % path.length, 1 / (segments[i].splits + 1));
            inserted++;
            segments[i].splits--;
        }
    }
};
exports.rotatePathForSmallestDistance = function (source, dest) {
    if (source.length !== dest.length) {
        throw new Error('Mismatched source and destination length.');
    }
    var moveToPopped = false;
    if (source[0].moveTo && dest[0].moveTo) {
        source.shift();
        dest.shift();
        moveToPopped = true;
    }
    var smallestOffset = 0;
    var minDistance = Infinity;
    for (var rotationOffset = 0; rotationOffset < source.length; rotationOffset++) {
        var distanceSum = 0;
        for (var i = 0; i < source.length; i++) {
            var dist = exports.distance(source[i], dest[(rotationOffset + i) % dest.length]);
            distanceSum += dist;
        }
        if (distanceSum < minDistance) {
            minDistance = distanceSum;
            smallestOffset = rotationOffset;
        }
    }
    if (smallestOffset === 0) {
        if (moveToPopped) {
            source.unshift({
                x: source[source.length - 1].x,
                y: source[source.length - 1].y,
                moveTo: true,
            });
            dest.unshift({
                x: dest[dest.length - 1].x,
                y: dest[dest.length - 1].y,
                moveTo: true,
            });
        }
        return;
    }
    var closed = dest[dest.length - 1].closed;
    var spliced = dest.splice(0, smallestOffset);
    dest.splice.apply(dest, [source.length, 0].concat(spliced));
    // Clean up
    if (closed) {
        dest[dest.length - 1].closed = true;
    }
    if (moveToPopped) {
        source.unshift({
            x: source[source.length - 1].x,
            y: source[source.length - 1].y,
            moveTo: true,
        });
        dest.unshift({
            x: dest[dest.length - 1].x,
            y: dest[dest.length - 1].y,
            moveTo: true,
        });
    }
    for (var i = 0; i < dest.length; i++) {
        if (i < dest.length - 1 && dest[i].closed) {
            delete dest[i].closed;
        }
        if (i > 0 && dest[i].moveTo) {
            delete dest[i].moveTo;
        }
    }
};
exports.ensurePathClockwise = function (path) {
    if (exports.polygonArea(path) > 0) {
        var reversed = SVGPathReversal_1.reverseNormalizedPath(SVGPathReversal_1.normalizePath(SVGPoints_1.default.pointsToPath(path)));
        path.splice(0, path.length);
        var reversedPoints = SVGPoints_1.default.pathToPoints(reversed);
        for (var i = 0; i < reversedPoints.length; i++) {
            path.push(reversedPoints[i]);
        }
    }
};
exports.normalizePointCurves = function (path) {
    for (var i = 1; i < path.length; i++) {
        if (path[i].curve) {
            // Convert quadratic to cubic bezier
            if (path[i].curve.type === 'quadratic') {
                var newCurve = {
                    type: 'cubic',
                };
                newCurve.x1 = path[i - 1].x + 2 / 3 * (path[i].curve.x1 - path[i - 1].x);
                newCurve.y1 = path[i - 1].y + 2 / 3 * (path[i].curve.y1 - path[i - 1].y);
                newCurve.x2 = path[i].x + 2 / 3 * (path[i].curve.x1 - path[i].x);
                newCurve.y2 = path[i].y + 2 / 3 * (path[i].curve.y2 - path[i].y);
                path[i].curve = newCurve;
            }
            else if (path[i].curve.type === 'arc') {
                console.warn('Paths with arcs are not yet supported.');
            }
            continue;
        }
        path[i].curve = {
            type: 'cubic',
            x1: path[i - 1].x,
            y1: path[i - 1].y,
            x2: path[i].x,
            y2: path[i].y,
        };
    }
};
exports.isMultiShape = function (path) {
    for (var i = 0; i < path.length; i++) {
        if (path[i].closed && i < path.length - 1) {
            return true;
        }
    }
    return false;
};
exports.synchronizePathStructure = function () {
    var paths = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        paths[_i] = arguments[_i];
    }
    // Multi-shape not yet supported for magic-morph
    if (paths.some(exports.isMultiShape)) {
        return;
    }
    var maxVerts = Math.max.apply(Math, paths.map(function (path) { return path.length; }));
    var validPaths = paths.filter(function (path) { return path.length && !path.some(function (_a) {
        var x = _a.x, y = _a.y;
        return isNaN(x) || isNaN(y);
    }); });
    validPaths.forEach(function (path) {
        exports.ensurePathClockwise(path);
        exports.distributeTotalVertices(path, maxVerts);
        exports.normalizePointCurves(path);
    });
    for (var i = 0; i < validPaths.length - 1; i++) {
        exports.rotatePathForSmallestDistance(validPaths[i], validPaths[i + 1]);
    }
};
//# sourceMappingURL=PathUtils.js.map