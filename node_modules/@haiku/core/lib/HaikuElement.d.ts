import { AxisString, BoundsSpec, BoundsSpecX, BoundsSpecY, BoundsSpecZ, BytecodeNode, BytecodeNodeMemoryObject, ClientRect, ComputedLayoutSpec, IHaikuComponent, IHaikuElement, LayoutSpec, StringableThreeDimensionalLayoutProperty, ThreeDimensionalLayoutProperty, TwoPointFiveDimensionalLayoutProperty } from './api';
import HaikuBase from './HaikuBase';
export declare const HAIKU_ID_ATTRIBUTE = "haiku-id";
export declare const HAIKU_TITLE_ATTRIBUTE = "haiku-title";
export declare const HAIKU_VAR_ATTRIBUTE = "haiku-var";
export declare const HAIKU_SOURCE_ATTRIBUTE = "haiku-source";
export declare const HAIKU_LOCKED_ATTRIBUTE = "haiku-locked";
export default class HaikuElement extends HaikuBase implements IHaikuElement {
    node: BytecodeNode;
    isHovered: boolean;
    constructor();
    readonly childNodes: (string | BytecodeNode)[];
    readonly children: HaikuElement[];
    readonly attributes: any;
    readonly type: any;
    readonly title: string;
    readonly source: string;
    readonly id: string;
    readonly className: string;
    readonly tagName: string;
    readonly nodeType: any;
    /**
     * @method subcomponent
     * @description Returns the HaikuComponent instance that manages nodes below this one.
     * This node is considered the 'wrapper' node and its child is considered the 'root'.
     */
    readonly subcomponent: IHaikuComponent;
    /**
     * @method instance
     * @description Returns the HaikuComponent instance that manages this node and those beneath.
     * This node is considered the 'root' node of the instance.
     */
    readonly instance: IHaikuComponent;
    /**
     * @method containee
     * @description Returns the HaikuComponent instance into which this node was passed as a container.
     */
    readonly containee: IHaikuComponent;
    readonly owner: IHaikuComponent;
    readonly top: IHaikuComponent;
    readonly instanceContext: any;
    readonly parentNode: BytecodeNode;
    readonly memory: BytecodeNodeMemoryObject;
    readonly parent: any;
    readonly layout: ComputedLayoutSpec;
    readonly layoutMatrix: number[];
    readonly layoutAncestry: any[];
    readonly layoutAncestryMatrices: number[][];
    readonly rootSVG: HaikuElement;
    readonly isChildOfDefs: boolean;
    getTranscludedElement(): HaikuElement | undefined;
    readonly rawLayout: LayoutSpec;
    readonly shown: boolean;
    readonly opacity: number;
    readonly shear: {
        xy: number;
        xz: number;
        yz: number;
    };
    readonly matrix: number[];
    readonly translation: ThreeDimensionalLayoutProperty;
    readonly rotation: ThreeDimensionalLayoutProperty;
    readonly scale: ThreeDimensionalLayoutProperty;
    readonly origin: ThreeDimensionalLayoutProperty;
    readonly offset: ThreeDimensionalLayoutProperty;
    readonly targets: Element[];
    readonly target: Element;
    readonly rotationX: number;
    readonly rotationY: number;
    readonly rotationZ: number;
    readonly scaleX: number;
    readonly scaleY: number;
    readonly scaleZ: number;
    readonly positionX: number;
    readonly positionY: number;
    readonly positionZ: number;
    readonly translationX: number;
    readonly translationY: number;
    readonly translationZ: number;
    readonly originX: number;
    readonly originY: number;
    readonly originZ: number;
    readonly offsetX: number;
    readonly offsetY: number;
    readonly offsetZ: number;
    /**
     * @description Returns the size as computed when the layout was last rendered.
     */
    readonly sizePrecomputed: ThreeDimensionalLayoutProperty;
    readonly sizePrecomputedX: number;
    readonly sizePrecomputedY: number;
    readonly sizePrecomputedZ: number;
    readonly size: ThreeDimensionalLayoutProperty;
    readonly sizeX: number;
    readonly sizeY: number;
    readonly sizeZ: number;
    readonly width: number;
    readonly height: number;
    readonly depth: number;
    readonly attributeWidth: number;
    readonly attributeHeight: number;
    readonly sizeAbsolute: StringableThreeDimensionalLayoutProperty;
    readonly sizeAbsoluteX: number | string;
    readonly sizeAbsoluteY: number | string;
    readonly sizeAbsoluteZ: number | string;
    readonly sizeMode: ThreeDimensionalLayoutProperty;
    readonly sizeModeX: number;
    readonly sizeModeY: number;
    readonly sizeModeZ: number;
    readonly sizeProportional: ThreeDimensionalLayoutProperty;
    readonly sizeProportionalX: number;
    readonly sizeProportionalY: number;
    readonly sizeProportionalZ: number;
    readonly sizeDifferential: ThreeDimensionalLayoutProperty;
    readonly sizeDifferentialX: number;
    readonly sizeDifferentialY: number;
    readonly sizeDifferentialZ: number;
    readonly properties: {
        shown: boolean;
        opacity: number;
        offset: ThreeDimensionalLayoutProperty;
        origin: ThreeDimensionalLayoutProperty;
        translation: ThreeDimensionalLayoutProperty;
        rotation: ThreeDimensionalLayoutProperty;
        scale: ThreeDimensionalLayoutProperty;
        shear: {
            xy: number;
            xz: number;
            yz: number;
        };
        sizeMode: ThreeDimensionalLayoutProperty;
        sizeProportional: ThreeDimensionalLayoutProperty;
        sizeDifferential: ThreeDimensionalLayoutProperty;
        sizeAbsolute: StringableThreeDimensionalLayoutProperty;
        size: ThreeDimensionalLayoutProperty;
        matrix: number[];
    };
    readonly componentId: string;
    computeSize(): ThreeDimensionalLayoutProperty;
    computeBoundsForAxis(axis: AxisString): BoundsSpecX | BoundsSpecY | BoundsSpecZ;
    computeContentBounds(): BoundsSpec;
    computeContentBoundsX(): BoundsSpecX;
    computeContentBoundsY(): BoundsSpecY;
    computeContentBoundsZ(): BoundsSpecZ;
    computeSizeForAxis(axis: AxisString): number;
    /**
     * @description For elements that only have a single child, we can save some computation
     * by looking up their defined absolute size instead of computing their bounding box.
     * In particular this is useful in the case of the component wrapper div and its one child.
     */
    getOnlyChildSize(axis: AxisString): number;
    computeSizeX(): number;
    computeSizeY(): number;
    computeSizeZ(): number;
    getComponentId(): string;
    isSimpleNode(): boolean;
    isTextNode(): boolean;
    isComponent(): boolean;
    isWrapper(): boolean;
    isSvgPrimitive(): boolean;
    componentMatches(selector: string): boolean;
    matches(selector: string): boolean;
    visit(iteratee: Function, filter?: (value: HaikuElement, index: number, array: HaikuElement[]) => boolean): any;
    visitDescendants(iteratee: Function, filter?: (value: HaikuElement, index: number, array: HaikuElement[]) => boolean): any;
    querySelector(selector: string): any;
    querySelectorAll(selector: string): any;
    getRawBoundingBoxPoints(): ThreeDimensionalLayoutProperty[];
    getLocallyTransformedBoundingBoxPoints(): ThreeDimensionalLayoutProperty[];
    getLocallyTransformedBoundingClientRect(): ClientRect;
    getNearestDefinedNonZeroAncestorSizeX(): number;
    getNearestDefinedNonZeroAncestorSizeY(): number;
    getNearestDefinedNonZeroAncestorSizeZ(): number;
    triggerHover(event: any): void;
    readonly selector: string;
    dump(): string;
    static getElementEventDelegator: (el: any) => IHaikuComponent;
    static transformVectorByMatrix: (out: any, v: any, m: any) => number[];
    static getRectFromPoints: (points: ThreeDimensionalLayoutProperty[] | TwoPointFiveDimensionalLayoutProperty[]) => ClientRect;
    static getBoundingBoxPoints: (points: any) => {
        x: any;
        y: any;
        z: number;
    }[];
    static transformPointsInPlace: (points: any, matrix: any) => any;
    static transformPointInPlace: (point: any, matrix: any) => any;
    static getAncestry: (ancestors: HaikuElement[], element: HaikuElement) => HaikuElement[];
    static __name__: string;
    static findByNode: (node: any) => HaikuElement;
    static connectNodeWithElement: (node: any, element: any) => void;
    static createByNode: (node: any) => HaikuElement;
    static findOrCreateByNode: (node: any) => HaikuElement;
    static useAutoSizing: (givenValue: any) => boolean;
    static computeLayout: (targetNode: BytecodeNode, parentNode: BytecodeNode) => ComputedLayoutSpec;
}
