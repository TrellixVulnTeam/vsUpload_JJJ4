"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var just_curves_1 = require("./vendor/just-curves");
var cubicBezier_1 = require("./vendor/just-curves/internal/cubicBezier");
var CENT = 1.0;
var OBJECT = 'object';
var NUMBER = 'number';
var STRING = 'string';
var PERCENT_REGEX = /^\d+(\.\d+)?%$/;
var PERCENT_SYMBOL = '%';
var isString = function (value) { return typeof value === STRING; };
function percentOfTime(t0, t1, tnow) {
    var span = t1 - t0;
    if (span === 0) {
        return CENT;
    } // No divide-by-zero
    var remaining = t1 - tnow;
    return CENT - remaining / span;
}
function valueAtPercent(v0, v1, pc) {
    var span = v1 - v0;
    var gain = span * pc;
    return v0 + gain;
}
function interpolateValue(v0, v1, t0, t1, tnow, curve) {
    var pc = percentOfTime(t0, t1, tnow);
    if (pc > CENT) {
        pc = CENT;
    }
    if (curve) {
        pc = curve(pc);
    }
    return valueAtPercent(v0, v1, pc);
}
exports.interpolate = function (now, curve, started, ends, origin, destination) {
    // Return early if we aren't tweening anything.
    if (origin === destination) {
        return origin;
    }
    var curveFunc;
    if (typeof curve === 'string') {
        // If curve is a string, transform into a function using justCurves
        curveFunc = just_curves_1.default[curve];
    }
    else if (Array.isArray(curve)) {
        // If curve is an array defining a Bezier curve, create a proper function
        curveFunc = cubicBezier_1.cubicBezier(curve[0], curve[1], curve[2], curve[3]);
    }
    else {
        // TODO: handle the case of custom functions, concerns for not enabling this
        // as of right now:
        // - serialization issues in all their various forms
        // (copy/paste, subcomponent, undo/redo, flush to disk)
        // - need to make sure not to crash if the function doesnâ€™t return a number
        // (without a `typeof` check on every tick)
        curveFunc = curve;
    }
    if (typeof curveFunc !== 'function') {
        return origin;
    }
    if (Array.isArray(origin) && Array.isArray(destination)) {
        var arrayOutput = [];
        for (var i = 0; i < origin.length; i++) {
            arrayOutput[i] = exports.interpolate(now, curveFunc, started, ends, origin[i], destination[i]);
        }
        return arrayOutput;
    }
    if (origin && typeof origin === OBJECT && destination && typeof destination === OBJECT) {
        var objectOutput = {};
        for (var key in origin) {
            objectOutput[key] = exports.interpolate(now, curveFunc, started, ends, origin[key], destination[key]);
        }
        return objectOutput;
    }
    if (typeof origin === NUMBER && typeof destination === NUMBER) {
        return interpolateValue(origin, destination, started, ends, now, curveFunc);
    }
    if (isString(origin) &&
        isString(destination) &&
        PERCENT_REGEX.test(origin) &&
        PERCENT_REGEX.test(destination)) {
        return interpolateValue(parseFloat(origin), parseFloat(destination), started, ends, now, curveFunc) + PERCENT_SYMBOL;
    }
    return origin;
};
//# sourceMappingURL=Interpolate.js.map