"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var HaikuNode_1 = require("./HaikuNode");
var compareSemver_1 = require("./helpers/compareSemver");
var migrateAutoSizing_1 = require("./helpers/migrateAutoSizing");
var applyCssLayout_1 = require("./layout/applyCssLayout");
var functionToRFO_1 = require("./reflection/functionToRFO");
var reifyRFO_1 = require("./reflection/reifyRFO");
var UpgradeVersionRequirement;
(function (UpgradeVersionRequirement) {
    UpgradeVersionRequirement["OriginSupport"] = "3.2.0";
    UpgradeVersionRequirement["TimelineDefaultFrames"] = "3.2.23";
    UpgradeVersionRequirement["CamelAutoSizingOffset3DOmnibus"] = "3.5.2";
})(UpgradeVersionRequirement || (UpgradeVersionRequirement = {}));
var HAIKU_ID_ATTRIBUTE = 'haiku-id';
var HAIKU_SOURCE_ATTRIBUTE = 'haiku-source';
var HAIKU_VAR_ATTRIBUTE = 'haiku-var';
var HAIKU_ROOT_DEFAULT_REGEX = /^web\+haikuroot:\/\//;
var HAIKU_ROOT_DEFAULT = 'web+haikuroot://';
var SRC_ATTRIBUTE = 'src';
var HREF_ATTRIBUTE = 'href';
var XLINKHREF_ATTRIBUTE = 'xlink:href';
var requiresUpgrade = function (coreVersion, requiredVersion) { return !coreVersion ||
    compareSemver_1.default(coreVersion, requiredVersion) < 0; };
var areKeyframesDefined = function (keyframeGroup) {
    return (keyframeGroup &&
        Object.keys(keyframeGroup).length > 0);
};
var ensure3dPreserved = function (node) {
    if (!node || !node.attributes || !node.attributes.style) {
        return;
    }
    var changed = false;
    // Only preserve 3D behavior if the node hasn't been *explicitly* defined yet
    if (!node.attributes.style.transformStyle) {
        node.attributes.style.transformStyle = 'preserve-3d';
        changed = true;
        if (!node.attributes.style.perspective) {
            node.attributes.style.perspective = 'inherit';
        }
    }
    return changed;
};
/**
 * Migrations are a mechanism to modify our bytecode from legacy format to the current format.
 * This always runs against production components' bytecode to ensure their data is a format
 * that the current version of the engine knows how to handle. There are two phases to migration:
 * the pre-phase, which runs before an initial .render call, and a post-phase, which runs after.
 */
exports.runMigrationsPrePhase = function (component, options) {
    var bytecode = component.bytecode;
    if (!bytecode.states) {
        bytecode.states = {};
    }
    if (!bytecode.metadata) {
        bytecode.metadata = {};
    }
    var coreVersion = bytecode.metadata.core || bytecode.metadata.player;
    // Convert the properties array to the states dictionary
    if (bytecode.properties) {
        var properties = bytecode.properties;
        delete bytecode.properties;
        for (var i = 0; i < properties.length; i++) {
            var propertySpec = properties[i];
            var updatedSpec = {};
            if (propertySpec.value !== undefined) {
                updatedSpec.value = propertySpec.value;
            }
            if (propertySpec.type !== undefined) {
                updatedSpec.type = propertySpec.type;
            }
            if (propertySpec.setter !== undefined) {
                updatedSpec.set = propertySpec.setter;
            }
            if (propertySpec.getter !== undefined) {
                updatedSpec.get = propertySpec.getter;
            }
            if (propertySpec.set !== undefined) {
                updatedSpec.set = propertySpec.set;
            }
            if (propertySpec.get !== undefined) {
                updatedSpec.get = propertySpec.get;
            }
            bytecode.states[propertySpec.name] = updatedSpec;
        }
    }
    // Convert the eventHandlers array into a dictionary
    // [{selector:'foo',name:'onclick',handler:function}] => {'foo':{'onclick':{handler:function}}}
    if (Array.isArray(bytecode.eventHandlers)) {
        var eventHandlers = bytecode.eventHandlers;
        delete bytecode.eventHandlers;
        bytecode.eventHandlers = {};
        for (var j = 0; j < eventHandlers.length; j++) {
            var eventHandlerSpec = eventHandlers[j];
            if (!bytecode.eventHandlers[eventHandlerSpec.selector]) {
                bytecode.eventHandlers[eventHandlerSpec.selector] = {};
            }
            bytecode.eventHandlers[eventHandlerSpec.selector][eventHandlerSpec.name] = {
                handler: eventHandlerSpec.handler,
            };
        }
    }
    if (bytecode.timelines) {
        // Expand all bytecode properties represented as shorthand.
        for (var timelineName in bytecode.timelines) {
            for (var selector in bytecode.timelines[timelineName]) {
                for (var property in bytecode.timelines[timelineName][selector]) {
                    if (bytecode.timelines[timelineName][selector][property] === null) {
                        delete bytecode.timelines[timelineName][selector][property];
                    }
                    else if (typeof bytecode.timelines[timelineName][selector][property] !== 'object') {
                        bytecode.timelines[timelineName][selector][property] = {
                            0: {
                                value: bytecode.timelines[timelineName][selector][property],
                            },
                        };
                    }
                }
            }
        }
    }
    var needsOmnibusUpgrade = requiresUpgrade(coreVersion, "3.5.2" /* CamelAutoSizingOffset3DOmnibus */);
    var referencesToUpdate = {};
    if (bytecode.template) {
        // y-overflow + preserve-3d leads to various rendering bugs, so for now, disable when overflow is available.
        // #FIXME
        var autoPreserve3d_1 = component.config.preserve3d === 'auto' && component.config.overflowY !== 'visible';
        HaikuNode_1.visitManaTree('0', bytecode.template, function (_, attributes) {
            if (typeof attributes !== 'object') {
                return;
            }
            if (options.mutations) {
                if (attributes.id) {
                    var prev = attributes.id;
                    var next = prev + '-' + options.mutations.referenceUniqueness;
                    attributes.id = next;
                    referencesToUpdate["#" + prev] = "#" + next;
                    referencesToUpdate['url(#' + prev + ')'] = 'url(#' + next + ')';
                }
            }
        }, null, 0);
        HaikuNode_1.visitManaTree('0', bytecode.template, function (elementName, attributes) {
            if (typeof attributes !== 'object') {
                return;
            }
            var timelineProperties = bytecode.timelines.Default["haiku:" + attributes[HAIKU_ID_ATTRIBUTE]] || {};
            // Hoist xlink:href up to the timeline if not already done. Older versions of Haiku installed xlink:href in the
            // attributes dictionary.
            if (attributes[XLINKHREF_ATTRIBUTE]) {
                timelineProperties[XLINKHREF_ATTRIBUTE] = { 0: { value: attributes[XLINKHREF_ATTRIBUTE] } };
                delete attributes[XLINKHREF_ATTRIBUTE];
            }
            if (options.mutations) {
                for (var property in timelineProperties) {
                    if (property !== SRC_ATTRIBUTE && property !== XLINKHREF_ATTRIBUTE && property !== HREF_ATTRIBUTE) {
                        continue;
                    }
                    for (var keyframe in timelineProperties[property]) {
                        var value = timelineProperties[property][keyframe].value;
                        if (HAIKU_ROOT_DEFAULT_REGEX.test(value)) {
                            timelineProperties[property][keyframe].value = value.replace(HAIKU_ROOT_DEFAULT, options.mutations.haikuRoot);
                        }
                        else if (referencesToUpdate[value]) {
                            timelineProperties[property][keyframe].value = referencesToUpdate[value];
                        }
                    }
                }
            }
            // Switch the legacy 'source' attribute to the new 'haiku-source'
            if (attributes.source) {
                attributes[HAIKU_SOURCE_ATTRIBUTE] = attributes.source;
                delete attributes.source;
            }
            if (attributes.identifier) {
                attributes[HAIKU_VAR_ATTRIBUTE] = attributes.identifier;
                delete attributes.identifier;
            }
            // Legacy backgroundColor was a root prop; in newer versions it's style.backgroundColor.
            // We only want to update this if the user *hasn't* explicitly set style.backroundColor.
            if (timelineProperties.backgroundColor && !timelineProperties['style.backgroundColor']) {
                timelineProperties['style.backgroundColor'] = timelineProperties.backgroundColor;
                delete timelineProperties.backgroundColor;
            }
            if (needsOmnibusUpgrade) {
                var transformStyleGroup = timelineProperties['style.transformStyle'];
                if (transformStyleGroup && transformStyleGroup[0] && transformStyleGroup[0].value === 'flat') {
                    delete timelineProperties['style.transformStyle'];
                }
                var perspectiveGroup = timelineProperties['style.perspective'];
                if (perspectiveGroup && perspectiveGroup[0] && perspectiveGroup[0].value === 'none') {
                    delete timelineProperties['style.perspective'];
                }
                // Retire sizing layout from any SVG sizeable in favor of explicit properties.
                if (typeof elementName === 'string' && applyCssLayout_1.SVG_SIZEABLES[elementName]) {
                    if (timelineProperties['sizeAbsolute.x']) {
                        timelineProperties.width = { 0: { value: timelineProperties['sizeAbsolute.x'][0].value } };
                        delete timelineProperties['sizeAbsolute.x'];
                        delete timelineProperties['sizeMode.x'];
                    }
                    if (timelineProperties['sizeAbsolute.y']) {
                        timelineProperties.height = { 0: { value: timelineProperties['sizeAbsolute.y'][0].value } };
                        delete timelineProperties['sizeAbsolute.y'];
                        delete timelineProperties['sizeMode.y'];
                    }
                    if (timelineProperties['sizeProportional.x']) {
                        timelineProperties.width = {
                            0: { value: Number(timelineProperties['sizeProportional.x'][0].value) * 100 + "%" },
                        };
                        delete timelineProperties['sizeProportional.x'];
                        delete timelineProperties['sizeMode.x'];
                    }
                    if (timelineProperties['sizeProportional.y']) {
                        timelineProperties.height = {
                            0: { value: Number(timelineProperties['sizeProportional.y'][0].value) * 100 + "%" },
                        };
                        delete timelineProperties['sizeProportional.y'];
                        delete timelineProperties['sizeMode.y'];
                    }
                }
            }
            // If we see that any 3D transformations are applied, automatically override flat perspective
            // if it hasn't been automatically set, so that 3D perspective "just works"
            if (!component.doPreserve3d &&
                autoPreserve3d_1 && (areKeyframesDefined(timelineProperties['rotation.x']) ||
                areKeyframesDefined(timelineProperties['rotation.y']) ||
                areKeyframesDefined(timelineProperties['translation.z']) ||
                areKeyframesDefined(timelineProperties['scale.z']))) {
                component.doPreserve3d = true;
            }
            if (!bytecode.timelines.Default["haiku:" + attributes[HAIKU_ID_ATTRIBUTE]] &&
                Object.keys(timelineProperties).length > 0) {
                // Update with our hot object if we inadvertently created this object during migration.
                bytecode.timelines.Default["haiku:" + attributes[HAIKU_ID_ATTRIBUTE]] = timelineProperties;
            }
        }, null, 0);
    }
    if (bytecode.timelines) {
        // Although not ideal, it's likely beneficial to do another pass through the timelines to fill in
        // reference uniqueness. This may allow us to avoid a rerender below.
        for (var timelineName in bytecode.timelines) {
            for (var selector in bytecode.timelines[timelineName]) {
                if (needsOmnibusUpgrade) {
                    // Migrate auto-sizing.
                    migrateAutoSizing_1.default(bytecode.timelines[timelineName][selector]);
                }
                // Ensure ID-based selectors like #box work.
                if (referencesToUpdate[selector]) {
                    bytecode.timelines[timelineName][referencesToUpdate[selector]] = bytecode.timelines[timelineName][selector];
                    delete bytecode.timelines[timelineName][selector];
                    selector = referencesToUpdate[selector];
                }
                for (var propertyName in bytecode.timelines[timelineName][selector]) {
                    if (needsOmnibusUpgrade) {
                        // Migrate camel-case property names.
                        var camelVariant = options.attrsHyphToCamel[propertyName];
                        if (camelVariant) {
                            bytecode.timelines[timelineName][selector][camelVariant] =
                                bytecode.timelines[timelineName][selector][propertyName];
                            delete bytecode.timelines[timelineName][selector][propertyName];
                        }
                    }
                    for (var keyframeMs in bytecode.timelines[timelineName][selector][propertyName]) {
                        var keyframeDesc = bytecode.timelines[timelineName][selector][propertyName][keyframeMs];
                        if (keyframeDesc && referencesToUpdate[keyframeDesc.value]) {
                            keyframeDesc.value = referencesToUpdate[keyframeDesc.value];
                        }
                    }
                }
            }
        }
    }
};
exports.runMigrationsPostPhase = function (component, options, version) {
    var bytecode = component.bytecode;
    var coreVersion = bytecode.metadata.core || bytecode.metadata.player;
    var needsRerender = false;
    if (component.doPreserve3d) {
        var node = component.node;
        if (node) {
            var didNodePreserve3dChange = ensure3dPreserved(node);
            if (didNodePreserve3dChange) {
                component.patches.push(node);
            }
        }
        // The wrapper also needs preserve-3d set for 3d-preservation to work
        var parent_1 = component.parentNode; // This should be the "wrapper div" node
        if (parent_1) {
            var didParentPreserve3dChange = ensure3dPreserved(parent_1);
            if (didParentPreserve3dChange) {
                component.patches.push(parent_1);
            }
        }
    }
    var needsCamelAutoSizingOffsetOmnibus = requiresUpgrade(coreVersion, "3.5.2" /* CamelAutoSizingOffset3DOmnibus */);
    if (needsCamelAutoSizingOffsetOmnibus) {
        var alsoMigrateOrigin_1 = requiresUpgrade(coreVersion, "3.2.0" /* OriginSupport */);
        component.visit(function (element) {
            var offsetX = 0;
            var offsetY = 0;
            var timelineProperties = bytecode.timelines.Default["haiku:" + element.getComponentId()];
            if (!timelineProperties) {
                return;
            }
            // Note: the migrations below are incorrect if align properties were ever defined on an element with explicit
            // size. Since in practice this never happened, this is fine.
            if (timelineProperties['align.x']) {
                var alignX = timelineProperties['align.x'][0] && timelineProperties['align.x'][0].value;
                if (typeof alignX === 'number') {
                    offsetX += alignX * element.getNearestDefinedNonZeroAncestorSizeX();
                }
            }
            if (timelineProperties['align.y']) {
                var alignY = timelineProperties['align.y'][0] && timelineProperties['align.y'][0].value;
                if (typeof alignY === 'number') {
                    offsetY += alignY * element.getNearestDefinedNonZeroAncestorSizeY();
                }
            }
            if (timelineProperties['mount.x']) {
                var mountX = timelineProperties['mount.x'][0] && timelineProperties['mount.x'][0].value;
                if (typeof mountX === 'number') {
                    offsetX -= mountX * element.getNearestDefinedNonZeroAncestorSizeX();
                }
            }
            if (timelineProperties['mount.y']) {
                var mountY = timelineProperties['mount.y'][0] && timelineProperties['mount.y'][0].value;
                if (typeof mountY === 'number') {
                    offsetY -= mountY * element.getNearestDefinedNonZeroAncestorSizeY();
                }
            }
            if (alsoMigrateOrigin_1) {
                // Prior to explicit origin support, we were applying a default origin of (0, 0, 0) for all objects, then
                // allowing the browser default for SVG elements (50%, 50%, 0px) be the effective transform-origin. This led to
                // inaccuracies in the layout system, specifically related to addressing translation on SVG elements and
                // addressing origin in general. Since as of the introduction of explicit origin support we had not made layout
                // offset addressable in Haiku, we can "backport" to the old coordinate system by simply offsetting layout
                // by its "origin error".
                if (element.tagName === 'svg') {
                    offsetX += 0.5 * element.getNearestDefinedNonZeroAncestorSizeX();
                    offsetY += 0.5 * element.getNearestDefinedNonZeroAncestorSizeY();
                }
                else {
                    offsetX += element.originX * element.getNearestDefinedNonZeroAncestorSizeX();
                    offsetY += element.originY * element.getNearestDefinedNonZeroAncestorSizeY();
                }
            }
            if (offsetX !== 0) {
                timelineProperties['offset.x'] = { 0: { value: offsetX } };
                needsRerender = true;
            }
            if (offsetY !== 0) {
                timelineProperties['offset.y'] = { 0: { value: offsetY } };
                needsRerender = true;
            }
            delete timelineProperties['align.x'];
            delete timelineProperties['align.y'];
            delete timelineProperties['align.z'];
            delete timelineProperties['mount.x'];
            delete timelineProperties['mount.y'];
            delete timelineProperties['mount.z'];
        });
    }
    component.eachEventHandler(function (eventSelector, eventName, _a) {
        var handler = _a.handler;
        if (!handler) {
            console.warn("Unable to migrate event handler for " + eventSelector + " " + eventName + " in " + component.$id);
            return;
        }
        var rfo = handler.__rfo || functionToRFO_1.default(handler).__function;
        var params = rfo.params;
        var body = rfo.body;
        var changed = false;
        if (requiresUpgrade(coreVersion, "3.2.23" /* TimelineDefaultFrames */)) {
            (['.seek(', '.gotoAndPlay(', '.gotoAndStop(']).forEach(function (methodSignature) {
                for (var cursor = 0; cursor < body.length; ++cursor) {
                    if (body.substring(cursor, cursor + methodSignature.length) !== methodSignature) {
                        continue;
                    }
                    changed = true;
                    // We have matched e.g. this.getDefaultTimeline().seek( at the string index of ".seek(".
                    // Using the assumption that the method arguments do not contain string arguments with parentheses inside,
                    // we can apply a simple parenthesis-balancing algorithm here.
                    cursor += methodSignature.length;
                    var openParens = 1;
                    while (openParens > 0 && cursor < body.length) {
                        if (body[cursor] === '(') {
                            openParens++;
                        }
                        else if (body[cursor] === ')') {
                            openParens--;
                        }
                        ++cursor;
                    }
                    // Essentially, replace .seek(foo) with .seek(foo, 'ms').
                    body = body.slice(0, cursor - 1) + ", 'ms')" + body.slice(cursor);
                }
            });
        }
        if (params.length < 4) {
            params = ['component', 'element', 'target', 'event'];
            changed = true;
        }
        if (changed) {
            bytecode.eventHandlers[eventSelector][eventName].handler = reifyRFO_1.default(__assign({}, rfo, { params: params,
                body: body }));
        }
    });
    if (needsRerender) {
        component.clearCaches();
        component.markForFullFlush();
    }
    // Ensure the bytecode metadata core version is recent.
    bytecode.metadata.core = version;
};
//# sourceMappingURL=Migration.js.map