"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var HaikuBase_1 = require("./HaikuBase");
var HaikuNode_1 = require("./HaikuNode");
var Layout3D_1 = require("./Layout3D");
exports.HAIKU_ID_ATTRIBUTE = 'haiku-id';
exports.HAIKU_TITLE_ATTRIBUTE = 'haiku-title';
exports.HAIKU_VAR_ATTRIBUTE = 'haiku-var';
exports.HAIKU_SOURCE_ATTRIBUTE = 'haiku-source';
exports.HAIKU_LOCKED_ATTRIBUTE = 'haiku-locked';
var SVG_PRIMITIVE_NAMES = {
    rect: true,
    line: true,
    circle: true,
    ellipse: true,
    path: true,
    polygon: true,
    polyline: true,
};
var DEFAULT_DEPTH = 0;
var DEFAULT_TAG_NAME = 'div';
var COMPONENT_PSEUDO_TAG_NAME = DEFAULT_TAG_NAME;
var SIZING_AXES = ['x', 'y', 'z'];
var TEXT_PSEUDO_TAG_NAME = '__text__';
var CSS_QUERY_MAPPING = {
    name: 'elementName',
    attributes: 'attributes',
    children: 'children',
};
var LAYOUT_DEFAULTS = Layout3D_1.default.createLayoutSpec();
var HaikuElement = /** @class */ (function (_super) {
    __extends(HaikuElement, _super);
    function HaikuElement() {
        var _this = _super.call(this) || this;
        _this.isHovered = false;
        return _this;
    }
    Object.defineProperty(HaikuElement.prototype, "childNodes", {
        get: function () {
            return (this.node &&
                ((this.memory && this.memory.children) || this.node.children)) || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "children", {
        get: function () {
            return this.childNodes.map(function (childNode) {
                return HaikuElement.findOrCreateByNode(childNode);
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "attributes", {
        get: function () {
            return (this.node && this.node.attributes) || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "type", {
        get: function () {
            return (this.node && this.node.elementName) || DEFAULT_TAG_NAME;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "title", {
        get: function () {
            return this.attributes[exports.HAIKU_TITLE_ATTRIBUTE];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "source", {
        get: function () {
            return this.attributes[exports.HAIKU_SOURCE_ATTRIBUTE];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "id", {
        get: function () {
            return this.attributes.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "className", {
        get: function () {
            return this.attributes.class;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "tagName", {
        get: function () {
            if (this.isTextNode()) {
                return TEXT_PSEUDO_TAG_NAME;
            }
            if (this.isComponent()) {
                return COMPONENT_PSEUDO_TAG_NAME;
            }
            return this.type || DEFAULT_TAG_NAME;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "nodeType", {
        get: function () {
            if (this.isTextNode()) {
                return 3;
            }
            return 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "subcomponent", {
        /**
         * @method subcomponent
         * @description Returns the HaikuComponent instance that manages nodes below this one.
         * This node is considered the 'wrapper' node and its child is considered the 'root'.
         */
        get: function () {
            return this.memory && this.memory.subcomponent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "instance", {
        /**
         * @method instance
         * @description Returns the HaikuComponent instance that manages this node and those beneath.
         * This node is considered the 'root' node of the instance.
         */
        get: function () {
            return this.memory && this.memory.instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "containee", {
        /**
         * @method containee
         * @description Returns the HaikuComponent instance into which this node was passed as a container.
         */
        get: function () {
            return this.memory && this.memory.containee;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "owner", {
        get: function () {
            if (this.instance) {
                return this.instance;
            }
            return this.parent && this.parent.owner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "top", {
        get: function () {
            return this.instanceContext && this.instanceContext.component;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "instanceContext", {
        get: function () {
            return this.memory && this.memory.context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "parentNode", {
        get: function () {
            return this.memory && this.memory.parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "memory", {
        get: function () {
            return this.node && this.node.__memory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "parent", {
        get: function () {
            return this.parentNode && HaikuElement.findOrCreateByNode(this.parentNode);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "layout", {
        get: function () {
            return this.node && this.node.layout && this.node.layout.computed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "layoutMatrix", {
        get: function () {
            return (this.layout && this.layout.matrix) || Layout3D_1.default.createMatrix();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "layoutAncestry", {
        get: function () {
            var ancestry = [];
            if (this.layout) {
                ancestry.unshift(this.layout);
            }
            // tslint:disable-next-line:no-this-assignment
            var ancestor = this;
            while (ancestor.parent) {
                ancestor = ancestor.parent;
                var layout = ancestor.layout;
                if (layout) {
                    ancestry.unshift(layout);
                }
            }
            return ancestry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "layoutAncestryMatrices", {
        get: function () {
            return this.layoutAncestry.filter(function (layout) { return !!layout.matrix; }).map(function (layout) { return layout.matrix; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "rootSVG", {
        get: function () {
            var parent = this.parent;
            while (parent) {
                if (parent.type === 'svg') {
                    return parent;
                }
                parent = parent.parent;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "isChildOfDefs", {
        get: function () {
            var parent = this.parent;
            while (parent) {
                if (parent.type === 'defs') {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    HaikuElement.prototype.getTranscludedElement = function () {
        if (this.type !== 'use') {
            return this;
        }
        var href = this.attributes['xlink:href'] || this.attributes.href;
        if (!href) {
            return;
        }
        var rootSVG = this.rootSVG;
        if (!rootSVG) {
            return;
        }
        var address = href.substr(1);
        var out;
        this.rootSVG.visit(function (desc) {
            if (desc.id === address) {
                out = desc;
                return false;
            }
        });
        return out;
    };
    Object.defineProperty(HaikuElement.prototype, "rawLayout", {
        get: function () {
            return this.node && this.node.layout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "shown", {
        get: function () {
            return this.layout && this.layout.shown;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "opacity", {
        get: function () {
            return this.layout && this.layout.opacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "shear", {
        get: function () {
            return this.layout && this.layout.shear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "matrix", {
        get: function () {
            return this.layout && this.layout.matrix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "translation", {
        get: function () {
            return (this.layout && this.layout.translation) || __assign({}, LAYOUT_DEFAULTS.translation);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "rotation", {
        get: function () {
            return (this.layout && this.layout.rotation) || __assign({}, LAYOUT_DEFAULTS.rotation);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "scale", {
        get: function () {
            return (this.layout && this.layout.scale) || __assign({}, LAYOUT_DEFAULTS.scale);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "origin", {
        get: function () {
            return (this.layout && this.layout.origin) || __assign({}, LAYOUT_DEFAULTS.origin);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "offset", {
        get: function () {
            return (this.layout && this.layout.offset) || __assign({}, LAYOUT_DEFAULTS.offset);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "targets", {
        get: function () {
            return (this.memory && this.memory.targets) || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "target", {
        get: function () {
            // Assume the most recently added target is the canonical target due to an implementation
            // detail in the Haiku editing environment; FIXME. On 3 Jun 2018 was changed from the first
            // added to the last added one to fix a bug related to ungrouping
            return this.targets[this.targets.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "rotationX", {
        get: function () {
            return this.rotation && this.rotation.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "rotationY", {
        get: function () {
            return this.rotation && this.rotation.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "rotationZ", {
        get: function () {
            return this.rotation && this.rotation.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "scaleX", {
        get: function () {
            return this.scale && this.scale.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "scaleY", {
        get: function () {
            return this.scale && this.scale.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "scaleZ", {
        get: function () {
            return this.scale && this.scale.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "positionX", {
        get: function () {
            return this.translation && this.translation.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "positionY", {
        get: function () {
            return this.translation && this.translation.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "positionZ", {
        get: function () {
            return this.translation && this.translation.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "translationX", {
        get: function () {
            return this.translation && this.translation.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "translationY", {
        get: function () {
            return this.translation && this.translation.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "translationZ", {
        get: function () {
            return this.translation && this.translation.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "originX", {
        get: function () {
            return this.origin && this.origin.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "originY", {
        get: function () {
            return this.origin && this.origin.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "originZ", {
        get: function () {
            return this.origin && this.origin.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "offsetX", {
        get: function () {
            return this.offset && this.offset.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "offsetY", {
        get: function () {
            return this.offset && this.offset.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "offsetZ", {
        get: function () {
            return this.offset && this.offset.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizePrecomputed", {
        /**
         * @description Returns the size as computed when the layout was last rendered.
         */
        get: function () {
            return this.layout && this.layout.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizePrecomputedX", {
        get: function () {
            return this.sizePrecomputed && this.sizePrecomputed.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizePrecomputedY", {
        get: function () {
            return this.sizePrecomputed && this.sizePrecomputed.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizePrecomputedZ", {
        get: function () {
            return this.sizePrecomputed && this.sizePrecomputed.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "size", {
        get: function () {
            return {
                x: this.sizeX,
                y: this.sizeY,
                z: this.sizeZ,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeX", {
        get: function () {
            return this.computeSizeX();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeY", {
        get: function () {
            return this.computeSizeY();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeZ", {
        get: function () {
            return this.computeSizeZ();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "width", {
        get: function () {
            return this.sizeX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "height", {
        get: function () {
            return this.sizeY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "depth", {
        get: function () {
            return this.sizeZ;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "attributeWidth", {
        get: function () {
            if (this.attributes && this.attributes.width) {
                return Number(this.attributes.width);
            }
            return;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "attributeHeight", {
        get: function () {
            if (this.attributes && this.attributes.height) {
                return Number(this.attributes.height);
            }
            return;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeAbsolute", {
        get: function () {
            return (this.rawLayout && this.rawLayout.sizeAbsolute) || __assign({}, LAYOUT_DEFAULTS.sizeAbsolute);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeAbsoluteX", {
        get: function () {
            return this.sizeAbsolute && this.sizeAbsolute.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeAbsoluteY", {
        get: function () {
            return this.sizeAbsolute && this.sizeAbsolute.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeAbsoluteZ", {
        get: function () {
            return this.sizeAbsolute && this.sizeAbsolute.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeMode", {
        get: function () {
            return this.rawLayout && this.rawLayout.sizeMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeModeX", {
        get: function () {
            return this.sizeMode && this.sizeMode.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeModeY", {
        get: function () {
            return this.sizeMode && this.sizeMode.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeModeZ", {
        get: function () {
            return this.sizeMode && this.sizeMode.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeProportional", {
        get: function () {
            return (this.rawLayout && this.rawLayout.sizeProportional) || __assign({}, LAYOUT_DEFAULTS.sizeProportional);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeProportionalX", {
        get: function () {
            return this.sizeProportional && this.sizeProportional.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeProportionalY", {
        get: function () {
            return this.sizeProportional && this.sizeProportional.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeProportionalZ", {
        get: function () {
            return this.sizeProportional && this.sizeProportional.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeDifferential", {
        get: function () {
            return (this.rawLayout && this.rawLayout.sizeDifferential) || __assign({}, LAYOUT_DEFAULTS.sizeDifferential);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeDifferentialX", {
        get: function () {
            return this.sizeDifferential && this.sizeDifferential.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeDifferentialY", {
        get: function () {
            return this.sizeDifferential && this.sizeDifferential.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "sizeDifferentialZ", {
        get: function () {
            return this.sizeDifferential && this.sizeDifferential.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "properties", {
        get: function () {
            return {
                shown: this.shown,
                opacity: this.opacity,
                offset: this.offset,
                origin: this.origin,
                translation: this.translation,
                rotation: this.rotation,
                scale: this.scale,
                shear: this.shear,
                sizeMode: this.sizeMode,
                sizeProportional: this.sizeProportional,
                sizeDifferential: this.sizeDifferential,
                sizeAbsolute: this.sizeAbsolute,
                size: this.size,
                matrix: this.matrix,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HaikuElement.prototype, "componentId", {
        get: function () {
            return this.getComponentId();
        },
        enumerable: true,
        configurable: true
    });
    HaikuElement.prototype.computeSize = function () {
        return {
            x: this.computeSizeX(),
            y: this.computeSizeY(),
            z: this.computeSizeZ(),
        };
    };
    HaikuElement.prototype.computeBoundsForAxis = function (axis) {
        if (axis === 'x') {
            return this.computeContentBoundsX();
        }
        if (axis === 'y') {
            return this.computeContentBoundsY();
        }
        if (axis === 'z') {
            return this.computeContentBoundsZ();
        }
    };
    HaikuElement.prototype.computeContentBounds = function () {
        return __assign({}, this.computeContentBoundsX(), this.computeContentBoundsY(), this.computeContentBoundsZ());
    };
    HaikuElement.prototype.computeContentBoundsX = function () {
        if (typeof this.sizeAbsolute.x === 'number') {
            return {
                left: null,
                right: null,
            };
        }
        var lefts = [];
        var rights = [];
        var children = this.children;
        if (children.length < 1) {
            return {
                left: null,
                right: null,
            };
        }
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            // These fields should account for the child's translation, rotation, scale, etc.
            var _a = child.getLocallyTransformedBoundingClientRect(), left = _a.left, right = _a.right;
            lefts.push(left);
            rights.push(right);
        }
        return {
            left: Math.min.apply(Math, lefts),
            right: Math.max.apply(Math, rights),
        };
    };
    HaikuElement.prototype.computeContentBoundsY = function () {
        if (typeof this.sizeAbsolute.y === 'number') {
            return {
                top: null,
                bottom: null,
            };
        }
        var tops = [];
        var bottoms = [];
        var children = this.children;
        if (children.length < 1) {
            return {
                top: null,
                bottom: null,
            };
        }
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            // These fields should account for the child's translation, rotation, scale, etc.
            var _a = child.getLocallyTransformedBoundingClientRect(), top_1 = _a.top, bottom = _a.bottom;
            tops.push(top_1);
            bottoms.push(bottom);
        }
        return {
            top: Math.min.apply(Math, tops),
            bottom: Math.max.apply(Math, bottoms),
        };
    };
    HaikuElement.prototype.computeContentBoundsZ = function () {
        return {
            front: null,
            back: null,
        };
    };
    HaikuElement.prototype.computeSizeForAxis = function (axis) {
        if (axis === 'x') {
            return this.computeSizeX();
        }
        if (axis === 'y') {
            return this.computeSizeY();
        }
        if (axis === 'z') {
            return this.computeSizeZ();
        }
    };
    /**
     * @description For elements that only have a single child, we can save some computation
     * by looking up their defined absolute size instead of computing their bounding box.
     * In particular this is useful in the case of the component wrapper div and its one child.
     */
    HaikuElement.prototype.getOnlyChildSize = function (axis) {
        var children = this.children;
        if (children.length !== 1) {
            return;
        }
        var child = children[0];
        if (!child || typeof child !== 'object') {
            return;
        }
        if (typeof child.sizeAbsolute[axis] === 'number') {
            return child.sizeAbsolute[axis];
        }
        return child.getOnlyChildSize(axis);
    };
    HaikuElement.prototype.computeSizeX = function () {
        // SVG primitives use native SVG layout instead of our system
        if (this.isSvgPrimitive() && typeof this.attributeWidth === 'number') {
            return this.attributeWidth;
        }
        if (typeof this.sizeAbsolute.x === 'number') {
            return this.sizeAbsolute.x;
        }
        var onlyChildSize = this.getOnlyChildSize('x');
        if (typeof onlyChildSize === 'number') {
            return onlyChildSize;
        }
        var _a = this.computeContentBoundsX(), left = _a.left, right = _a.right;
        return right - left;
    };
    HaikuElement.prototype.computeSizeY = function () {
        // SVG primitives use native SVG layout instead of our system
        if (this.isSvgPrimitive() && typeof this.attributeHeight === 'number') {
            return this.attributeHeight;
        }
        if (typeof this.sizeAbsolute.y === 'number') {
            return this.sizeAbsolute.y;
        }
        var onlyChildSize = this.getOnlyChildSize('y');
        if (typeof onlyChildSize === 'number') {
            return onlyChildSize;
        }
        var _a = this.computeContentBoundsY(), top = _a.top, bottom = _a.bottom;
        return bottom - top;
    };
    HaikuElement.prototype.computeSizeZ = function () {
        if (typeof this.sizeAbsolute.z === 'number') {
            return this.sizeAbsolute.z;
        }
        var onlyChildSize = this.getOnlyChildSize('z');
        if (typeof onlyChildSize === 'number') {
            return onlyChildSize;
        }
        var _a = this.computeContentBoundsZ(), front = _a.front, back = _a.back;
        return back - front;
    };
    HaikuElement.prototype.getComponentId = function () {
        return this.attributes[exports.HAIKU_ID_ATTRIBUTE];
    };
    HaikuElement.prototype.isSimpleNode = function () {
        return !this.isComponent();
    };
    HaikuElement.prototype.isTextNode = function () {
        return typeof this.node !== 'object';
    };
    HaikuElement.prototype.isComponent = function () {
        return !!this.instance;
    };
    HaikuElement.prototype.isWrapper = function () {
        return !!this.subcomponent;
    };
    HaikuElement.prototype.isSvgPrimitive = function () {
        return !!SVG_PRIMITIVE_NAMES[this.tagName];
    };
    HaikuElement.prototype.componentMatches = function (selector) {
        if (!this.isComponent()) {
            return false;
        }
        var trimmed = selector.trim();
        var source = this.source;
        var title = this.title;
        var id = this.id;
        return (trimmed === COMPONENT_PSEUDO_TAG_NAME ||
            trimmed === source ||
            trimmed === title ||
            trimmed === id);
    };
    HaikuElement.prototype.matches = function (selector) {
        return (this.componentMatches(selector) ||
            HaikuNode_1.cssMatchOne(this.node, selector, CSS_QUERY_MAPPING));
    };
    HaikuElement.prototype.visit = function (iteratee, filter) {
        var result = iteratee(this);
        if (result !== false) {
            return this.visitDescendants(iteratee, filter);
        }
        return result;
    };
    HaikuElement.prototype.visitDescendants = function (iteratee, filter) {
        if (this.parent && this.parent.isWrapper()) {
            // Avoids traversing down into a subcomponent.
            return true;
        }
        var children = filter ? this.children.filter(filter) : this.children;
        for (var i = 0; i < children.length; i++) {
            var result = children[i].visit(iteratee, filter);
            if (result === false) {
                return result;
            }
        }
        return true;
    };
    HaikuElement.prototype.querySelector = function (selector) {
        var _this = this;
        return this.cacheFetch("querySelector:" + selector, function () {
            var out;
            _this.visitDescendants(function (element) {
                if (element.matches(selector)) {
                    out = element;
                    // Returning `false` short-circuits the visitor
                    return false;
                }
            });
            return out;
        });
    };
    HaikuElement.prototype.querySelectorAll = function (selector) {
        var _this = this;
        return this.cacheFetch("querySelectorAll:" + selector, function () {
            var out = [];
            _this.visitDescendants(function (element) {
                if (element.matches(selector)) {
                    out.push(element);
                }
            });
            return out;
        });
    };
    HaikuElement.prototype.getRawBoundingBoxPoints = function () {
        var _a = this.computeSize(), x = _a.x, y = _a.y;
        return [
            { x: 0, y: 0, z: 0 }, { x: x / 2, y: 0, z: 0 }, { x: x, y: 0, z: 0 },
            { x: 0, y: y / 2, z: 0 }, { x: x / 2, y: y / 2, z: 0 }, { x: x, y: y / 2, z: 0 },
            { y: y, x: 0, z: 0 }, { y: y, x: x / 2, z: 0 }, { y: y, x: x, z: 0 },
        ];
    };
    HaikuElement.prototype.getLocallyTransformedBoundingBoxPoints = function () {
        return HaikuElement.transformPointsInPlace(this.getRawBoundingBoxPoints(), HaikuElement.computeLayout(this.node, null).matrix);
    };
    HaikuElement.prototype.getLocallyTransformedBoundingClientRect = function () {
        var points = this.getLocallyTransformedBoundingBoxPoints();
        return HaikuElement.getRectFromPoints(points);
    };
    HaikuElement.prototype.getNearestDefinedNonZeroAncestorSizeX = function () {
        var x = this.sizeAbsolute.x;
        if (typeof x === 'number' && x > 0) {
            return x;
        }
        if (this.parent) {
            return this.parent.getNearestDefinedNonZeroAncestorSizeX();
        }
        return 1;
    };
    HaikuElement.prototype.getNearestDefinedNonZeroAncestorSizeY = function () {
        var y = this.sizeAbsolute.y;
        if (typeof y === 'number' && y > 0) {
            return y;
        }
        if (this.parent) {
            return this.parent.getNearestDefinedNonZeroAncestorSizeY();
        }
        return 1;
    };
    HaikuElement.prototype.getNearestDefinedNonZeroAncestorSizeZ = function () {
        var z = this.sizeAbsolute.z;
        if (typeof z === 'number' && z > 0) {
            return z;
        }
        if (this.parent) {
            return this.parent.getNearestDefinedNonZeroAncestorSizeZ();
        }
        return 1;
    };
    HaikuElement.prototype.triggerHover = function (event) {
        var manager = this.top;
        // In case of the root container of a render tree
        if (!manager) {
            manager = this.containee;
        }
        // Not sure how we'd get here, but if we do, skip this process
        if (!manager || manager.isDeactivated) {
            return;
        }
        // tslint:disable-next-line:no-this-assignment
        var hoverable = this;
        // If no last hovered element, there's nothing to unhover.
        var mustUnhover = manager.lastHoveredElement !== undefined;
        var hovers = [];
        while (hoverable) {
            // If the last hovered element is an ancestor,
            // we _don't_ want to unhover it—that's the
            // annoying browser behavior we're trying to
            // "fix" in the first place.
            if (mustUnhover && manager.lastHoveredElement === hoverable) {
                mustUnhover = false;
            }
            // If we are hovered here, by virtue of this algorithm we are hovered above.
            if (hoverable.isHovered) {
                break;
            }
            hovers.push(hoverable);
            hoverable.isHovered = true;
            hoverable = hoverable.parent;
        }
        hovers.forEach(function (hov) {
            var delegator = HaikuElement.getElementEventDelegator(hov);
            if (delegator && !delegator.isDeactivated) {
                delegator.routeEventToHandlerAndEmitWithoutBubblingAndWithoutGlobalHandlers(hov.selector, 'hover', [hov, hov.target, event]);
            }
        });
        var unhovers = [];
        // We must be in a different branch of the tree.
        if (mustUnhover) {
            var unhoverable = manager.lastHoveredElement;
            // Stop until we hit the common hovered ancestor (wherever we break'ed above).
            while (unhoverable && unhoverable !== hoverable) {
                unhovers.push(unhoverable);
                unhoverable.isHovered = false;
                unhoverable = unhoverable.parent;
            }
        }
        unhovers.forEach(function (unhov) {
            var delegator = HaikuElement.getElementEventDelegator(unhov);
            if (delegator && !delegator.isDeactivated) {
                delegator.routeEventToHandlerAndEmitWithoutBubblingAndWithoutGlobalHandlers(unhov.selector, 'unhover', [unhov, unhov.target, event]);
            }
        });
        manager.lastHoveredElement = this;
    };
    Object.defineProperty(HaikuElement.prototype, "selector", {
        get: function () {
            return "haiku:" + this.getComponentId();
        },
        enumerable: true,
        configurable: true
    });
    HaikuElement.prototype.dump = function () {
        return this.$id + ":<" + this.tagName + ">(" + (this.getComponentId() || '[container]') + ")";
    };
    HaikuElement.getElementEventDelegator = function (el) {
        if (!el) {
            return;
        }
        if (el.isComponent()) {
            return el;
        }
        return el.owner;
    };
    HaikuElement.transformVectorByMatrix = function (out, v, m) {
        out[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12];
        out[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13];
        out[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14];
        return out;
    };
    HaikuElement.getRectFromPoints = function (points) {
        var top = Math.min(points[0].y, points[2].y, points[6].y, points[8].y);
        var bottom = Math.max(points[0].y, points[2].y, points[6].y, points[8].y);
        var left = Math.min(points[0].x, points[2].x, points[6].x, points[8].x);
        var right = Math.max(points[0].x, points[2].x, points[6].x, points[8].x);
        var width = Math.abs(bottom - top);
        var height = Math.abs(right - left);
        return {
            top: top,
            right: right,
            bottom: bottom,
            left: left,
            width: width,
            height: height,
        };
    };
    HaikuElement.getBoundingBoxPoints = function (points) {
        var x1 = points[0].x;
        var y1 = points[0].y;
        var x2 = points[0].x;
        var y2 = points[0].y;
        points.forEach(function (point) {
            if (point.x < x1) {
                x1 = point.x;
            }
            else if (point.x > x2) {
                x2 = point.x;
            }
            if (point.y < y1) {
                y1 = point.y;
            }
            else if (point.y > y2) {
                y2 = point.y;
            }
        });
        var w = x2 - x1;
        var h = y2 - y1;
        return [
            { x: x1, y: y1, z: 0 }, { x: x1 + w / 2, y: y1, z: 0 }, { x: x2, y: y1, z: 0 },
            { x: x1, y: y1 + h / 2, z: 0 }, { x: x1 + w / 2, y: y1 + h / 2, z: 0 }, { x: x2, y: y1 + h / 2, z: 0 },
            { x: x1, y: y2, z: 0 }, { x: x1 + w / 2, y: y2, z: 0 }, { x: x2, y: y2, z: 0 },
        ];
    };
    HaikuElement.transformPointsInPlace = function (points, matrix) {
        for (var i = 0; i < points.length; i++) {
            HaikuElement.transformPointInPlace(points[i], matrix);
        }
        return points;
    };
    HaikuElement.transformPointInPlace = function (point, matrix) {
        var offset = HaikuElement.transformVectorByMatrix([], [point.x, point.y, point.z], matrix);
        point.x = offset[0];
        point.y = offset[1];
        point.z = offset[2];
        return point;
    };
    HaikuElement.getAncestry = function (ancestors, element) {
        ancestors.unshift(element);
        if (element.parent) {
            HaikuElement.getAncestry(ancestors, element.parent);
        }
        return ancestors;
    };
    // tslint:disable-next-line:variable-name
    HaikuElement.__name__ = 'HaikuElement';
    HaikuElement.findByNode = function (node) {
        var registry = HaikuBase_1.default.getRegistryForClass(HaikuElement);
        for (var i = 0; i < registry.length; i++) {
            if (registry[i].node === node) {
                return registry[i];
            }
        }
        return;
    };
    HaikuElement.connectNodeWithElement = function (node, element) {
        // In case the element wasn't initialized yet
        if (element) {
            element.node = node;
        }
        // In case we got a string or null node
        if (node && typeof node === 'object') {
            // The purpose of the __memory object is to allow a mutable reference to be
            // passed around even when the node's base attributes are cloned. Also
            // to consolidate a host of __* properties which were becoming unweildy.
            //
            // Important: Platform-specific renderers may attach properties to this object;
            // for example the HaikuDOMRenderer attaches list of .targets (DOM nodes).
            if (!node.__memory) {
                node.__memory = {};
            }
            node.__memory.element = element;
        }
    };
    HaikuElement.createByNode = function (node) {
        var element = new HaikuElement();
        HaikuElement.connectNodeWithElement(node, element);
        return element;
    };
    HaikuElement.findOrCreateByNode = function (node) {
        var found;
        if (node && typeof node === 'object') {
            found = node.__memory && node.__memory.element;
        }
        if (!found) {
            found = HaikuElement.findByNode(node);
        }
        if (found) {
            HaikuElement.connectNodeWithElement(node, found);
            return found;
        }
        return HaikuElement.createByNode(node);
    };
    HaikuElement.useAutoSizing = function (givenValue) {
        return (givenValue === Layout3D_1.AUTO_SIZING_TOKEN ||
            // Legacy. Because HaikuComponent#render gets called before Migration.runMigrations,
            // the legacy value won't be correctly migrated to 'auto' by the time this gets called
            // for the very first time, so we keep it around for backwards compat. Jun 22, 2018.
            givenValue === true);
    };
    HaikuElement.computeLayout = function (targetNode, parentNode) {
        var layoutSpec = targetNode.layout;
        var targetSize = {
            x: null,
            y: null,
            z: null,
        };
        var parentBounds = (parentNode &&
            parentNode.layout &&
            parentNode.layout.computed &&
            parentNode.layout.computed.bounds);
        var targetBounds = {
            left: null,
            top: null,
            right: null,
            bottom: null,
            front: null,
            back: null,
        };
        var leftOffset = 0;
        var topOffset = 0;
        if (parentBounds) {
            if (typeof parentBounds.left === 'number') {
                leftOffset += parentBounds.left;
            }
            if (typeof parentBounds.top === 'number') {
                topOffset += parentBounds.top;
            }
        }
        var targetElement = HaikuElement.findOrCreateByNode(targetNode);
        // We'll define this later if any axes are requesting SIZE_PROPORTIONAL. It isn't needed for SIZE_ABSOLUTE.
        var parentsizeAbsolute;
        for (var i = 0; i < SIZING_AXES.length; i++) {
            var sizeAxis = SIZING_AXES[i];
            switch (layoutSpec.sizeMode[sizeAxis]) {
                case Layout3D_1.SIZE_PROPORTIONAL:
                    if (!parentsizeAbsolute) {
                        parentsizeAbsolute = (parentNode &&
                            parentNode.layout &&
                            parentNode.layout.computed &&
                            parentNode.layout.computed.size) || { x: 0, y: 0, z: 0 };
                        if (parentsizeAbsolute.z === undefined || parentsizeAbsolute.z === null) {
                            parentsizeAbsolute.z = DEFAULT_DEPTH;
                        }
                        if (parentsizeAbsolute.x === 0 && parentsizeAbsolute.y === 0 && parentsizeAbsolute.z === 0) {
                            // Size must be inherited from an ancestor above parent. Traverse upward until we find it.
                            var traversalParentNode = targetNode;
                            while (traversalParentNode) {
                                traversalParentNode = traversalParentNode.__memory && traversalParentNode.__memory.parent;
                                if (traversalParentNode && traversalParentNode.layout && traversalParentNode.layout.computed) {
                                    Object.assign(parentsizeAbsolute, traversalParentNode.layout.computed.size);
                                    break;
                                }
                            }
                        }
                    }
                    // Size is calculated as: parentSizeValue * sizeProportional + sizeProportional.
                    targetSize[sizeAxis] = parentsizeAbsolute[sizeAxis] * layoutSpec.sizeProportional[sizeAxis] +
                        layoutSpec.sizeDifferential[sizeAxis];
                    break;
                case Layout3D_1.SIZE_ABSOLUTE:
                    var givenValue = layoutSpec.sizeAbsolute[sizeAxis];
                    // Implements "auto"-sizing: Use content size if available, otherwise fallback to parent
                    if (HaikuElement.useAutoSizing(givenValue)) {
                        targetSize[sizeAxis] = targetElement.computeSizeForAxis(sizeAxis);
                        Object.assign(targetBounds, targetElement.computeBoundsForAxis(sizeAxis));
                    }
                    else {
                        targetSize[sizeAxis] = givenValue; // Assume the given value is numeric
                    }
                    break;
            }
        }
        var virtualSpec = __assign({}, layoutSpec, { offset: {
                x: layoutSpec.offset.x - leftOffset,
                y: layoutSpec.offset.y - topOffset,
                z: layoutSpec.offset.z,
            } });
        var targetMatrix = Layout3D_1.default.computeMatrix(virtualSpec, targetSize);
        return {
            shown: layoutSpec.shown,
            opacity: layoutSpec.opacity,
            offset: layoutSpec.offset,
            origin: layoutSpec.origin,
            translation: layoutSpec.translation,
            rotation: layoutSpec.rotation,
            scale: layoutSpec.scale,
            shear: layoutSpec.shear,
            sizeMode: layoutSpec.sizeMode,
            sizeProportional: layoutSpec.sizeProportional,
            sizeDifferential: layoutSpec.sizeDifferential,
            sizeAbsolute: layoutSpec.sizeAbsolute,
            size: targetSize,
            matrix: targetMatrix,
            bounds: targetBounds,
        };
    };
    return HaikuElement;
}(HaikuBase_1.default));
exports.default = HaikuElement;
//# sourceMappingURL=HaikuElement.js.map