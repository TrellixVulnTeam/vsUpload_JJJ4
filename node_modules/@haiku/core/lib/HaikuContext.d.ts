/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
import { BytecodeOptions, HaikuBytecode, IHaikuClock, IHaikuContext, IRenderer } from './api';
import HaikuBase from './HaikuBase';
import HaikuComponent from './HaikuComponent';
export interface ComponentFactory {
    (mount: Element, config: BytecodeOptions): HaikuComponent;
    bytecode?: HaikuBytecode;
    renderer?: IRenderer;
    mount?: Element;
    context?: HaikuContext;
    component?: HaikuComponent;
    PLAYER_VERSION?: string;
    CORE_VERSION?: string;
}
/**
 * @class HaikuContext
 * @description Represents the root of a Haiku component tree within an application.
 * A Haiku component tree may contain many components, but there is only one context.
 * The context is where information shared by all components in the tree should go, e.g. clock time.
 */
export default class HaikuContext extends HaikuBase implements IHaikuContext {
    clock: IHaikuClock;
    component: HaikuComponent;
    config: any;
    container: any;
    CORE_VERSION: any;
    mount: any;
    platform: any;
    PLAYER_VERSION: any;
    renderer: any;
    tickables: any;
    ticks: any;
    unmountedTickables: any;
    constructor(mount: any, renderer: any, platform: any, bytecode: any, config: any);
    /**
     * @method getRootComponent
     * @description Returns the HaikuComponent managed by this context.
     */
    getRootComponent(): HaikuComponent;
    /**
     * @method getClock
     * @description Returns the HaikuClock instance associated with this context.
     */
    getClock(): IHaikuClock;
    /**
     * @method contextMount
     * @description Adds this context the global update loop.
     */
    contextMount(): void;
    /**
     * @method contextUnmount
     * @description Removes this context from global update loop.
     */
    contextUnmount(): void;
    destroy(): void;
    /**
     * @method addTickable
     * @description Add a tickable object to the list of those that will be called on every clock tick.
     * This only adds if the given object isn't already present in the list.
     */
    addTickable(tickable: any): void;
    /**
     * @method assignConfig
     * @description Updates internal configuration options, assigning those passed in.
     * Also updates the configuration of the clock instance and managed component instance.
     */
    assignConfig(config: BytecodeOptions, options?: {
        skipComponentAssign?: boolean;
    }): void;
    /**
     * @method getContainer
     * @description Returns the container, a virtual-element-like object that provides sizing
     * constraints at the topmost/outermost level from which the descendant layout can be calculated.
     */
    getContainer(doForceRecalc?: boolean): any;
    /**
     * @method performFullFlushRender
     * @description Updates the entire component tree, flushing updates to the rendering medium.
     */
    performFullFlushRender(): void;
    /**
     * @method performPatchRender
     * @description Updates the component tree, but only updating properties we know have changed.
     */
    performPatchRender(skipCache?: boolean): void;
    /**
     * @method updateMountRootStyles
     * @description Reconciles the properties of the rendering medium's mount element with any
     * configuration options that have been passed in, e.g. CSS overflow settings.
     */
    updateMountRootStyles(): void;
    /**
     * @method tick
     * @description Advances the component animation by one tick. Note that one tick is not necessarily
     * equivalent to one frame. If the animation frame loop is running too fast, the clock may wait before
     * incrementing the frame number. In other words, a tick implies an update but not necessarily a change.
     */
    tick(skipCache?: boolean): void;
    /**
     * @method getGlobalUserState
     * @description Since the core renderer is medium-agnostic, we rely on the renderer to provide data
     * about the current user (the mouse position, for example). This method is just a convenience wrapper.
     */
    getGlobalUserState(): any;
    /**
     * @function createComponentFactory
     * @description Returns a factory function that can create a HaikuComponent and run it upon a mount.
     * The created instance runs using the passed-in renderer, bytecode, options, and platform.
     */
    static createComponentFactory: (rendererClass: any, bytecode: any, haikuConfigFromFactoryCreator: any, platform: any) => ComponentFactory;
    static PLAYER_VERSION: any;
    static CORE_VERSION: any;
    static __name__: string;
}
