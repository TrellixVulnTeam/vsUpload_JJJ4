/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
import { BytecodeEventHandlerDescriptor, BytecodeHelpers, BytecodeNode, BytecodeOptions, Curve, HaikuBytecode, IHaikuClock, IHaikuComponent, IHaikuContext, TwoPointFiveDimensionalLayoutProperty } from './api';
import HaikuElement from './HaikuElement';
import HaikuTimeline, { PlaybackFlag, TimeUnit } from './HaikuTimeline';
import { RFO } from './reflection/functionToRFO';
import StateTransitionManager, { StateTransitionParameters, StateValues } from './StateTransitionManager';
import { CurveSpec } from './vendor/svg-points/types';
export interface IComputedValue {
    computedValue: any;
    didValueChangeSinceLastRequest: boolean;
    didValueOriginateFromExplicitKeyframeDefinition: boolean;
}
export declare const VERSION: any;
/**
 * An interface for a "hot component" to patch into the renderer.
 *
 * Hot components are intended to be applied during hot editing when an immutable-looking thing happens to mutate
 * without marking the owner HaikuComponent instance for a full flush render.
 */
export interface HotComponent {
    timelineName: string;
    selector: string;
    propertyNames: string[];
}
export interface ClearCacheOptions {
    clearStates?: boolean;
}
export default class HaikuComponent extends HaikuElement implements IHaikuComponent {
    isDeactivated: any;
    isSleeping: any;
    private mutableTimelines;
    private parsedValueClusters;
    _states: any;
    bytecode: HaikuBytecode;
    /**
     * @deprecated
     */
    _bytecode: any;
    config: any;
    container: any;
    context: IHaikuContext;
    CORE_VERSION: any;
    doAlwaysFlush: any;
    doesNeedFullFlush: any;
    doPreserve3d: any;
    guests: {
        [haikuId: string]: HaikuComponent;
    };
    helpers: any;
    lastHoveredElement: HaikuElement;
    hooks: any;
    host: HaikuComponent;
    playback: any;
    PLAYER_VERSION: any;
    registeredEventHandlers: any;
    state: any;
    stateTransitionManager: StateTransitionManager;
    needsExpand: boolean;
    patches: BytecodeNode[];
    constructor(bytecode: HaikuBytecode, context: IHaikuContext, host: HaikuComponent, config: BytecodeOptions, container: any);
    /**
     * @description Track elements that are at the horizon of what we want to render, i.e., a list of
     * virtual elements that we don't want to make any updates lower than in the tree.
     */
    markHorizonElement(virtualElement: any): void;
    /**
     * @description Returns true/false whether this element is one that we don't want to make any
     *  updates further down its tree.
     */
    isHorizonElement(virtualElement: any): boolean;
    isLiveMode(): boolean;
    isEditMode(): boolean;
    registerGuest(subcomponent: HaikuComponent): void;
    visitGuestHierarchy(visitor: Function): void;
    visitGuests(visitor: Function): void;
    callRemount(incomingConfig: any, skipMarkForFullFlush?: boolean): void;
    destroy(): void;
    callUnmount(): void;
    assignConfig(incomingConfig: any): this;
    set(key: any, value: any): this;
    get(key: any): any;
    setState(states: StateValues, transitionParameter?: StateTransitionParameters): this;
    getStates(): any;
    clearCaches(options?: ClearCacheOptions): void;
    cacheNodeWithSelectorKey(node: any): void;
    clearStates(): void;
    getClock(): IHaikuClock;
    getTemplate(): any;
    getHelpers(): BytecodeHelpers;
    getTimelines(): {};
    fetchTimelines(): {};
    getTimeline(name: any): HaikuTimeline;
    fetchTimeline(name: any, descriptor: any): HaikuTimeline;
    getDefaultTimeline(): HaikuTimeline;
    stopAllTimelines(): void;
    startAllTimelines(): void;
    startTimeline(timelineName: any): void;
    stopTimeline(timelineName: any): void;
    /**
     * @description Convenience alias for HaikuTimeline#gotoAndPlay
     */
    gotoAndPlay(amount: number, unit?: TimeUnit): void;
    /**
     * @description Convenience alias for HaikuTimeline#gotoAndStop
     */
    gotoAndStop(amount: number, unit?: TimeUnit): void;
    /**
     * @description Convenience alias for HaikuTimeline#pause
     */
    pause(): void;
    /**
     * @description Convenience alias for HaikuTimeline#stop
     */
    stop(): void;
    /**
     * @description Convenience alias for HaikuTimeline#seek
     */
    seek(amount: number, unit?: TimeUnit): void;
    /**
     * @description Convenience alias for HaikuTimeline#start
     */
    start(): void;
    /**
     * @description Convenience alias for HaikuTimeline#play
     */
    play(options?: any): void;
    getTimelineDescriptor(timelineName: string): import("./api").BytecodeTimeline;
    getInjectables(): any;
    /**
     * @method _deactivate
     * @description When hot-reloading a component during editing, this can be used to
     * ensure that this component doesn't keep updating after its replacement is loaded.
     */
    deactivate(): void;
    activate(): void;
    sleepOn(): void;
    sleepOff(): void;
    /**
     * @method dump
     * @description Dump serializable info about this object
     */
    dump(): string;
    getBytecodeMetadata(): import("./api").BytecodeMetadata;
    getBytecodeRelpath(): string;
    getBytecodeProject(): string;
    getBytecodeOrganization(): string;
    getAddressableProperties(out?: {}): {};
    bindStates(): void;
    defineSettableState(stateSpec: any, stateSpecName: string): void;
    allEventHandlers(): any;
    eachEventHandler(iteratee: (eventSelector: string, eventName: string, descriptor: BytecodeEventHandlerDescriptor) => void): void;
    routeEventToHandler(eventSelectorGiven: string, eventNameGiven: string, eventArgs: any): void;
    setHook(hookName: string, hookFn: Function): void;
    callHook(hookName: string, ...args: any[]): void;
    callEventHandler(eventsSelector: string, eventName: string, handler: Function, eventArgs: any): any;
    routeEventToHandlerAndEmit(eventSelectorGiven: string, eventNameGiven: string, eventArgs: any): void;
    routeEventToHandlerAndEmitWithoutBubbling(eventSelectorGiven: string, eventNameGiven: string, eventArgs: any): void;
    routeEventToHandlerAndEmitWithoutBubblingAndWithoutGlobalHandlers(eventSelectorGiven: string, eventNameGiven: string, eventArgs: any): void;
    /**
     * @description A more expressive form of `emit` that allows the user to route
     * events to specific collections of elements/components in the tree using labels,
     * selectors, etc. This method is provided in lieu of providing an individual method
     * for every possible topology.
     */
    send(route: string, name: string, ...args: any[]): void;
    emitToAncestors(name: string, ...args: any[]): void;
    emitWithoutBubbling(key: string, ...args: any[]): void;
    markForFullFlush(): void;
    unmarkForFullFlush(): void;
    shouldPerformFullFlush(): any;
    private expandIfNeeded;
    performFullFlushRenderWithRenderer(renderer: any, options?: any): any;
    performPatchRenderWithRenderer(renderer: any, options: any, skipCache: boolean): void;
    render(options?: any): BytecodeNode;
    patch(options?: any, skipCache?: boolean): {};
    applyGlobalBehaviors(options?: any): void;
    applyLocalBehaviors(isPatchOperation: any, skipCache?: boolean): void;
    getProjectRootPathWithTerminatingSlash(): string;
    applyPropertyToNode(node: any, name: string, value: any, timeline: HaikuTimeline): any;
    findElementsByHaikuId(componentId: any): any[];
    nodesCacheKey(selector: string): string;
    private manaTreeCached;
    findMatchingNodesByCSSSelector(manaTree: any, selector: string): any[];
    private hydrateMutableTimelines;
    addHotComponent(hotComponent: HotComponent): void;
    controlTime(timelineName: string, timelineTime: number): void;
    getPropertiesGroup(timelineName: string, flexId: string): import("./api").BytecodeTimelineProperties;
    /**
     * Execute state transitions.
     */
    tickStateTransitions(): void;
    /**
     * Reset states to initial values by using State Transitions. Default to linear
     */
    resetStatesToInitialValuesWithTransition(duration: number, curve?: Curve): void;
    /**
     * @description Get the topmost component in the hierarchy.
     */
    readonly top: HaikuComponent;
    getRootComponent(): any;
    emitFromRootComponent(eventName: string, attachedObject: any): void;
    evaluate(expr: string): any;
    summon(injectable: string): any;
    evaluateExpression(fn: any, timelineName: string, flexId: string, matchingElement: any, propertyName: string, keyframeMs: any, keyframeCluster: any): any;
    summonSummonables(paramsArray: any, timelineName: string, flexId: string, matchingElement: any, propertyName: string, keyframeMs: any, keyframeCluster: any): any[];
    private fetchParsedValueCluster;
    generateFinalValueFromParsedValue(timelineName: any, flexId: any, matchingElement: any, outputName: any, computedValue: any): any;
    grabValue(timelineName: string, flexId: string, matchingElement: any, propertyName: string, keyframeCluster: any, timelineTime: number, isPatchOperation: boolean, skipCache: boolean): IComputedValue;
    getPreviousSummonees(timelineName: any, flexId: any, propertyName: any, keyframeMs: any): any;
    cacheSummonees(timelineName: any, flexId: any, propertyName: any, keyframeMs: any, summonees: any): any;
    getPreviousEvaluation(timelineName: any, flexId: any, propertyName: any, keyframeMs: any): any;
    cacheEvaluation(timelineName: any, flexId: any, propertyName: any, keyframeMs: any, evaluation: any): any;
    private getParseeWithKeys;
    private clusterParseeIsStable;
    didChangeValue(timelineName: any, flexId: any, matchingElement: any, outputName: any, outputValue: any): boolean;
    getSummonablesSchema(): {};
    transformContextPointToLocalPoint(point: TwoPointFiveDimensionalLayoutProperty): TwoPointFiveDimensionalLayoutProperty;
    getParser(outputName: any): any;
    getGenerator(outputName: any): any;
    static __name__: string;
    static PLAYER_VERSION: any;
    static CORE_VERSION: any;
    static INJECTABLES: any;
    static FORBIDDEN_EXPRESSION_TOKENS: {
        new: boolean;
        this: boolean;
        with: boolean;
        delete: boolean;
        export: boolean;
        extends: boolean;
        super: boolean;
        class: boolean;
        abstract: boolean;
        interface: boolean;
        static: boolean;
        label: boolean;
        goto: boolean;
        private: boolean;
        import: boolean;
        public: boolean;
        do: boolean;
        native: boolean;
        package: boolean;
        transient: boolean;
        implements: boolean;
        protected: boolean;
        throws: boolean;
        synchronized: boolean;
        final: boolean;
        window: boolean;
        document: boolean;
        global: boolean;
        eval: boolean;
        uneval: boolean;
        Function: boolean;
        EvalError: boolean;
        require: boolean;
        module: boolean;
        exports: boolean;
        Module: boolean;
        arguments: boolean;
        callee: boolean;
        prototpye: boolean;
        __proto__: boolean;
        freeze: boolean;
        setPrototypeOf: boolean;
        constructor: boolean;
        defineProperties: boolean;
        defineProperty: boolean;
    };
    static PARSERS: {
        'style.stroke': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.fill': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.backgroundColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.borderBottomColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.borderColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.borderLeftColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.borderRightColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.borderTopColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.floodColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.lightingColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'style.stopColor': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        stroke: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        fill: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        floodColor: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        lightingColor: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        stopColor: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        backgroundColor: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        animateColor: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        feColor: {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'flood-color': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'lighting-color': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'stop-color': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'background-color': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'animate-color': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        'fe-color': {
            parse: (value: any) => any;
            generate: (value: any) => any;
        };
        d: {
            parse: (value: string | CurveSpec[]) => CurveSpec[];
            generate: (value: string | CurveSpec[]) => string;
        };
        points: {
            parse: (value: any) => any[];
            generate: (value: any) => string;
        };
    };
    static all: () => HaikuComponent[];
}
export declare const getNodeCompositeId: (node: any) => string;
export interface ClonedFunction {
    (...args: any[]): void;
    __rfo?: RFO;
}
export declare const clone: (value: any, binding: any) => any;
/**
 * 'Vanities' are functions that provide special handling for applied properties.
 * So for example, if a component wants to apply 'foo.bar'=3 to a <div> in its template,
 * the renderer will look in the vanities dictionary to see if there is a
 * vanity 'foo.bar' available, and if so, pass the value 3 into that function.
 * The function, in turn, knows how to apply that value to the virtual element passed into
 * it. In the future these will be defined by components themselves as inputs; for now,
 * we are keeping a whitelist of possible vanity handlers which the renderer directly
 * loads and calls.
 */
export declare const getVanity: (elementName: string, propertyName: string) => any;
export declare const LAYOUT_3D_VANITIES: {
    shown: (_: any, element: any, value: any) => void;
    opacity: (_: any, element: any, value: any) => void;
    'position.x': (name: any, element: any, value: any) => void;
    'position.y': (name: any, element: any, value: any) => void;
    'rotation.x': (_: any, element: any, value: any) => void;
    'rotation.y': (_: any, element: any, value: any) => void;
    'rotation.z': (_: any, element: any, value: any) => void;
    'offset.x': (name: any, element: any, value: any) => void;
    'offset.y': (name: any, element: any, value: any) => void;
    'offset.z': (name: any, element: any, value: any) => void;
    'origin.x': (name: any, element: any, value: any) => void;
    'origin.y': (name: any, element: any, value: any) => void;
    'origin.z': (name: any, element: any, value: any) => void;
    'scale.x': (name: any, element: any, value: any) => void;
    'scale.y': (name: any, element: any, value: any) => void;
    'scale.z': (name: any, element: any, value: any) => void;
    'sizeAbsolute.x': (name: any, element: any, value: any) => void;
    'sizeAbsolute.y': (name: any, element: any, value: any) => void;
    'sizeAbsolute.z': (name: any, element: any, value: any) => void;
    'sizeDifferential.x': (name: any, element: any, value: any) => void;
    'sizeDifferential.y': (name: any, element: any, value: any) => void;
    'sizeDifferential.z': (name: any, element: any, value: any) => void;
    'sizeMode.x': (name: any, element: any, value: any) => void;
    'sizeMode.y': (name: any, element: any, value: any) => void;
    'sizeMode.z': (name: any, element: any, value: any) => void;
    'sizeProportional.x': (name: any, element: any, value: any) => void;
    'sizeProportional.y': (name: any, element: any, value: any) => void;
    'sizeProportional.z': (name: any, element: any, value: any) => void;
    'shear.xy': (name: any, element: any, value: any) => void;
    'shear.xz': (name: any, element: any, value: any) => void;
    'shear.yz': (name: any, element: any, value: any) => void;
    'translation.x': (name: any, element: any, value: any) => void;
    'translation.y': (name: any, element: any, value: any) => void;
    'translation.z': (name: any, element: any, value: any) => void;
};
export declare const VANITIES: {
    '*': {
        'style.WebkitTapHighlightColor': (_: any, element: any, value: any) => void;
        content: (name: any, element: any, value: any, context: any, timeline: any, receiver: any, sender: any) => void;
        playback: (name: any, element: any, value: any, context: IHaikuContext, timeline: HaikuTimeline, receiver: HaikuComponent, sender: HaikuComponent) => void;
        'controlFlow.placeholder': (name: any, element: any, value: any, context: any, timeline: any, receiver: any, sender: any) => void;
        'controlFlow.repeat': (name: string, element: any, value: any, context: IHaikuContext, timeline: HaikuTimeline, receiver: HaikuComponent, sender: HaikuComponent) => void;
        'controlFlow.if': (name: string, element: any, value: any, context: IHaikuContext, timeline: HaikuTimeline, receiver: HaikuComponent, sender: HaikuComponent) => void;
        shown: (_: any, element: any, value: any) => void;
        opacity: (_: any, element: any, value: any) => void;
        'position.x': (name: any, element: any, value: any) => void;
        'position.y': (name: any, element: any, value: any) => void;
        'rotation.x': (_: any, element: any, value: any) => void;
        'rotation.y': (_: any, element: any, value: any) => void;
        'rotation.z': (_: any, element: any, value: any) => void;
        'offset.x': (name: any, element: any, value: any) => void;
        'offset.y': (name: any, element: any, value: any) => void;
        'offset.z': (name: any, element: any, value: any) => void;
        'origin.x': (name: any, element: any, value: any) => void;
        'origin.y': (name: any, element: any, value: any) => void;
        'origin.z': (name: any, element: any, value: any) => void;
        'scale.x': (name: any, element: any, value: any) => void;
        'scale.y': (name: any, element: any, value: any) => void;
        'scale.z': (name: any, element: any, value: any) => void;
        'sizeAbsolute.x': (name: any, element: any, value: any) => void;
        'sizeAbsolute.y': (name: any, element: any, value: any) => void;
        'sizeAbsolute.z': (name: any, element: any, value: any) => void;
        'sizeDifferential.x': (name: any, element: any, value: any) => void;
        'sizeDifferential.y': (name: any, element: any, value: any) => void;
        'sizeDifferential.z': (name: any, element: any, value: any) => void;
        'sizeMode.x': (name: any, element: any, value: any) => void;
        'sizeMode.y': (name: any, element: any, value: any) => void;
        'sizeMode.z': (name: any, element: any, value: any) => void;
        'sizeProportional.x': (name: any, element: any, value: any) => void;
        'sizeProportional.y': (name: any, element: any, value: any) => void;
        'sizeProportional.z': (name: any, element: any, value: any) => void;
        'shear.xy': (name: any, element: any, value: any) => void;
        'shear.xz': (name: any, element: any, value: any) => void;
        'shear.yz': (name: any, element: any, value: any) => void;
        'translation.x': (name: any, element: any, value: any) => void;
        'translation.y': (name: any, element: any, value: any) => void;
        'translation.z': (name: any, element: any, value: any) => void;
    };
};
export declare const getFallback: (elementName: string, propertyName: string) => any;
export declare const FALLBACKS: {
    '*': {
        shown: boolean;
        opacity: number;
        content: string;
        'offset.x': number;
        'offset.y': number;
        'offset.z': number;
        'origin.x': number;
        'origin.y': number;
        'origin.z': number;
        'translation.x': number;
        'translation.y': number;
        'translation.z': number;
        'rotation.x': number;
        'rotation.y': number;
        'rotation.z': number;
        'scale.x': number;
        'scale.y': number;
        'scale.z': number;
        'shear.xy': number;
        'shear.xz': number;
        'shear.yz': number;
        'sizeAbsolute.x': number;
        'sizeAbsolute.y': number;
        'sizeAbsolute.z': number;
        'sizeProportional.x': number;
        'sizeProportional.y': number;
        'sizeProportional.z': number;
        'sizeDifferential.x': number;
        'sizeDifferential.y': number;
        'sizeDifferential.z': number;
        'sizeMode.x': number;
        'sizeMode.y': number;
        'sizeMode.z': number;
        'style.overflowX': string;
        'style.overflowY': string;
        'style.zIndex': number;
        'style.WebkitTapHighlightColor': string;
        width: number;
        height: number;
        x: number;
        y: number;
        r: number;
        cx: number;
        cy: number;
        rx: number;
        ry: number;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        playback: PlaybackFlag;
        'controlFlow.repeat': any;
        'controlFlow.placeholder': any;
    };
};
export declare const LAYOUT_3D_SCHEMA: {
    shown: string;
    opacity: string;
    'offset.x': string;
    'offset.y': string;
    'offset.z': string;
    'origin.x': string;
    'origin.y': string;
    'origin.z': string;
    'translation.x': string;
    'translation.y': string;
    'translation.z': string;
    'rotation.x': string;
    'rotation.y': string;
    'rotation.z': string;
    'scale.x': string;
    'scale.y': string;
    'scale.z': string;
    'shear.xy': string;
    'shear.xz': string;
    'shear.yz': string;
    'sizeAbsolute.x': string;
    'sizeAbsolute.y': string;
    'sizeAbsolute.z': string;
    'sizeProportional.x': string;
    'sizeProportional.y': string;
    'sizeProportional.z': string;
    'sizeDifferential.x': string;
    'sizeDifferential.y': string;
    'sizeDifferential.z': string;
    'sizeMode.x': string;
    'sizeMode.y': string;
    'sizeMode.z': string;
};
export declare const ATTRS_CAMEL_TO_HYPH: {
    accentHeight: string;
    alignmentBaseline: string;
    arabicForm: string;
    baselineShift: string;
    capHeight: string;
    clipPath: string;
    clipRule: string;
    colorInterpolation: string;
    colorInterpolationFilters: string;
    colorProfile: string;
    colorRendering: string;
    dominantBaseline: string;
    enableBackground: string;
    fillOpacity: string;
    fillRule: string;
    floodColor: string;
    floodOpacity: string;
    fontFamily: string;
    fontSize: string;
    fontSizeAdjust: string;
    fontStretch: string;
    fontStyle: string;
    fontVariant: string;
    fontWeight: string;
    glyphName: string;
    glyphOrientationHorizontal: string;
    glyphOrientationVertical: string;
    horizAdvX: string;
    horizOriginX: string;
    imageRendering: string;
    letterSpacing: string;
    lightingColor: string;
    markerEnd: string;
    markerMid: string;
    markerStart: string;
    overlinePosition: string;
    overlineThickness: string;
    panose1: string;
    paintOrder: string;
    pointerEvents: string;
    renderingIntent: string;
    shapeRendering: string;
    stopColor: string;
    stopOpacity: string;
    strikethroughPosition: string;
    strikethroughThickness: string;
    strokeDasharray: string;
    strokeDashoffset: string;
    strokeLinecap: string;
    strokeLinejoin: string;
    strokeMiterlimit: string;
    strokeOpacity: string;
    strokeWidth: string;
    textAnchor: string;
    textDecoration: string;
    textRendering: string;
    underlinePosition: string;
    underlineThickness: string;
    unicodeBidi: string;
    unicodeRange: string;
    unitsPerEm: string;
    vAlphabetic: string;
    vHanging: string;
    vIdeographic: string;
    vMathematical: string;
    vectorEffect: string;
    vertAdvY: string;
    vertOriginX: string;
    vertOriginY: string;
    wordSpacing: string;
    writingMode: string;
    xHeight: string;
};
export declare const ATTRS_HYPH_TO_CAMEL: {};
