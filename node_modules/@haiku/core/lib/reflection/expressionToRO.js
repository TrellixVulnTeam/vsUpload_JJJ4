"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var functionToRFO_1 = require("./functionToRFO");
var isSerializableScalar_1 = require("./isSerializableScalar");
var FUNCTION = 'function';
var OBJECT = 'object';
// The inverse of this function is 'reifyRO'
function expressionToRO(exp, options) {
    if (typeof exp === FUNCTION) {
        return functionToRFO_1.default(exp);
    }
    if (Array.isArray(exp)) {
        return arrayToRO(exp);
    }
    if (exp && typeof exp === OBJECT) {
        // If we got an object that already looks like a 'RO', then pass it through unmodified.
        // Note that we only want to include the super-private members __*, since the object might
        // inadvertently be storing other properties that aren't suited to serialization.
        // See 'reifyRO' for detail on how this serialization works on the opposite side.
        if (exp.__function) {
            return {
                __function: exp.__function,
            };
        }
        if (exp.__reference) {
            return {
                __reference: exp.__reference,
            };
        }
        if (exp.__value) {
            return {
                __value: exp.__value,
            };
        }
        return objectToRO(exp, options);
    }
    if (isSerializableScalar_1.default(exp)) {
        return exp;
    }
    return exp;
}
exports.default = expressionToRO;
function arrayToRO(arr) {
    var out = [];
    for (var i = 0; i < arr.length; i++) {
        out[i] = expressionToRO(arr[i], null);
    }
    return out;
}
function objectToRO(obj, options) {
    var out = {};
    for (var key in obj) {
        if (options && options.ignore && options.ignore.test(key)) {
            continue;
        }
        out[key] = expressionToRO(obj[key], options);
    }
    return out;
}
//# sourceMappingURL=expressionToRO.js.map