/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
import { IHaikuComponent, IRenderer, MountLayout } from '../../api';
import HaikuBase from '../../HaikuBase';
export default class HaikuDOMRenderer extends HaikuBase implements IRenderer {
    mount: any;
    config: any;
    user: any;
    shouldCreateContainer: any;
    constructor(mount: any, config: any);
    clear(): void;
    getMountForComponent(component: IHaikuComponent): any;
    render(virtualContainer: any, virtualTree: any, component: any): any;
    patch(component: any, deltas: any): void;
    menuize(component: any): void;
    mixpanel(mixpanelToken: any, component: any): void;
    hasSizing(): boolean;
    getZoom(): any;
    getPan(): {
        x: any;
        y: any;
    };
    createContainer(out?: MountLayout): MountLayout;
    getDocument(): any;
    getWindow(): any;
    initialize(): void;
    decideMountElement(component: IHaikuComponent, selector: string, name: string): any;
    mountEventListener(component: IHaikuComponent, selector: string, name: string, listener: Function): void;
    getHaikuElementFromTarget(target: any): any;
    shouldListenerReceiveEvent: (name: string, rewritten: string, event: any, match: Element, mount: any) => boolean;
    /**
     * @description An opportunity to return an event aligned with our own API semantics.
     * Keep in mind that the three elements involved here may be different:
     *   this.mount - the host node for the component, the node we actually attach listeners to.
     *   event.target - the element on which the event actually originated
     *   elementListenedTo - the element that the user is listening to the event on
     */
    wrapEvent(eventName: string, nativeEvent: any, elementListenedTo: any, hostComponent: IHaikuComponent): any;
    getUser(): {
        zoom: any;
        pan: {
            x: any;
            y: any;
        };
        mouse: {
            x: number;
            y: number;
            z: number;
            down: any;
            buttons: any[];
        };
        keys: any;
        touches: any[];
        mouches: any[];
    };
    static createTagNode(domElement: any, virtualElement: any, parentVirtualElement: any, component: any): any;
    static appendChild(alreadyChildElement: any, virtualElement: any, parentDomElement: any, parentVirtualElement: any, component: any): any;
    static replaceElement(domElement: any, virtualElement: any, parentDomNode: any, parentVirtualElement: any, component: any): any;
    static updateElement(domElement: any, virtualElement: any, parentNode: any, parentVirtualElement: any, component: any, isPatchOperation: any): any;
    static renderTree(domElement: any, virtualElement: any, virtualChildren: any, component: any, isPatchOperation: any, doSkipChildren: any): any;
    static shouldElementBeReplaced(domElement: any, virtualElement: any, component: any): boolean;
    static cloneAttributes(attributes: any): {};
    static cloneVirtualElement(virtualElement: any): {
        elementName: any;
        attributes: {};
        children: any;
        __memory: any;
    };
    static __name__: string;
}
