"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var HaikuBase_1 = require("../../HaikuBase");
var HaikuComponent_1 = require("../../HaikuComponent");
var assign_1 = require("../../vendor/assign");
var applyLayout_1 = require("./applyLayout");
var assignAttributes_1 = require("./assignAttributes");
var createRightClickMenu_1 = require("./createRightClickMenu");
var createSvgElement_1 = require("./createSvgElement");
var createTextNode_1 = require("./createTextNode");
var getElementSize_1 = require("./getElementSize");
var getLocalDomEventPosition_1 = require("./getLocalDomEventPosition");
var getTypeAsString_1 = require("./getTypeAsString");
var isBlankString_1 = require("./isBlankString");
var isTextNode_1 = require("./isTextNode");
var normalizeName_1 = require("./normalizeName");
var removeElement_1 = require("./removeElement");
var replaceElementWithText_1 = require("./replaceElementWithText");
var isNil = function (v) {
    return v === undefined || v === null;
};
var connectTarget = function (virtualNode, domElement) {
    if (virtualNode && typeof virtualNode === 'object') {
        // This normally happens in HaikuComponent.hydrateNode, but we might be operating
        // as a thin-renderer where no hydration has occurred; so do the bootstrapping here.
        if (!virtualNode.__memory) {
            virtualNode.__memory = {};
        }
        // A virtual node can have multiple targets in the DOM due to an implementation
        // detail in the Haiku editing environment; FIXME
        if (!virtualNode.__memory.targets) {
            virtualNode.__memory.targets = [];
        }
        if (virtualNode.__memory.targets.indexOf(domElement) === -1) {
            virtualNode.__memory.targets.push(domElement);
        }
    }
};
// tslint:disable:variable-name
var HaikuDOMRenderer = /** @class */ (function (_super) {
    __extends(HaikuDOMRenderer, _super);
    function HaikuDOMRenderer(mount, config) {
        var _this = _super.call(this) || this;
        _this.shouldListenerReceiveEvent = function (name, rewritten, event, match, mount) {
            if (name === 'hover' || name === 'unhover') {
                return event.target === match;
            }
            if (name === 'keyup' || name === 'keydown' || name === 'keypress') {
                // See not about keyboard handling in HaikuDOMRenderer#decideMountElement
                if (mount === _this.getWindow()) {
                    return true;
                }
            }
            // Since we subscribe to events from the root element, we rewrite these as 'mouseover' and 'mouseout'
            // so we can adequately capture "bubbled" enters/leaves to meet the 99% expectation of users. Then
            // we mimic the bubbling logic here so the semantics align with normal DOM semantics
            if (name === 'mouseenter' || name === 'mouseleave') {
                return (match === event.target &&
                    ( // Don't fire if the user's mouse went from inside the child into the target
                    !match.contains ||
                        !match.contains(event.relatedTarget)));
            }
            return (match === event.target ||
                (match.contains && match.contains(event.target)));
        };
        _this.mount = mount;
        _this.user = {
            mouse: {
                x: 0,
                y: 0,
                down: 0,
                buttons: [0, 0, 0],
            },
            keys: {},
            touches: [],
            mouches: [],
        };
        _this.config = config;
        _this.shouldCreateContainer = true;
        // Ensure we don't conflict with existing content in the mount
        _this.clear();
        return _this;
    }
    HaikuDOMRenderer.prototype.clear = function () {
        if (this.mount) {
            while (this.mount.firstChild) {
                this.mount.removeChild(this.mount.firstChild);
            }
        }
    };
    HaikuDOMRenderer.prototype.getMountForComponent = function (component) {
        // The component without a host is the root component, and uses this node.
        if (!component.host) {
            return this.mount;
        }
        return component.target && component.target.parentNode;
    };
    HaikuDOMRenderer.prototype.render = function (virtualContainer, virtualTree, component) {
        return HaikuDOMRenderer.renderTree(
        // The injected mount is for the case that the caller wants to render into a node
        // other than the root node of the context, for example calling render on a subcomponent
        this.getMountForComponent(component), virtualContainer, [virtualTree], component, false, // isPatchOperation
        false);
    };
    HaikuDOMRenderer.prototype.patch = function (component, deltas) {
        // The component upstream may use an empty value to indicate a no-op
        if (!deltas || Object.keys(deltas).length < 1) {
            return;
        }
        for (var compositeId in deltas) {
            var virtualElement = deltas[compositeId];
            var parentVirtualElement = virtualElement.__memory && virtualElement.__memory.parent;
            var domTargets = virtualElement.__memory && virtualElement.__memory.targets;
            if (!domTargets) {
                continue;
            }
            for (var i = 0; i < domTargets.length; i++) {
                var domTarget = domTargets[i];
                if (!domTarget.parentNode) {
                    continue;
                }
                HaikuDOMRenderer.updateElement(domTarget, // DOM node
                virtualElement, // mana node
                domTarget.parentNode, // DOM node
                parentVirtualElement, // mana node
                component, true);
            }
        }
    };
    HaikuDOMRenderer.prototype.menuize = function (component) {
        return createRightClickMenu_1.default(this.mount, component);
    };
    HaikuDOMRenderer.prototype.mixpanel = function (mixpanelToken, component) {
        return mixpanelInit(mixpanelToken, component);
    };
    HaikuDOMRenderer.prototype.hasSizing = function () {
        return this.config && this.config.sizing && this.config.sizing !== 'normal';
    };
    HaikuDOMRenderer.prototype.getZoom = function () {
        return ((this.config && this.config.zoom) || 1.0);
    };
    HaikuDOMRenderer.prototype.getPan = function () {
        return {
            x: (this.config && this.config.pan && this.config.pan.x) || 0,
            y: (this.config && this.config.pan && this.config.pan.y) || 0,
        };
    };
    HaikuDOMRenderer.prototype.createContainer = function (out) {
        if (out === void 0) { out = {}; }
        var size;
        if (this.mount) {
            size = getElementSize_1.default(this.mount);
        }
        else {
            console.warn('[haiku dom renderer] mount empty; using fallback size');
            size = { x: 1, y: 1 };
        }
        out.layout = {
            computed: {
                size: size,
            },
        };
        if (!this.hasSizing() || !this.config.alwaysComputeSizing) {
            this.shouldCreateContainer = false;
        }
        return out;
    };
    HaikuDOMRenderer.prototype.getDocument = function () {
        return this.mount.ownerDocument;
    };
    HaikuDOMRenderer.prototype.getWindow = function () {
        var doc = this.getDocument();
        return doc.defaultView || doc.parentWindow;
    };
    HaikuDOMRenderer.prototype.initialize = function () {
        var _this = this;
        var user = this.user;
        var setMouse = function (mouseEvent) {
            // Since the mount itself might be subject to sizing styles that we cannot
            // use to calculate appropriately, use the top element i.e. the 'artboard'
            var topElement = _this.mount.childNodes[0];
            if (topElement) {
                var pos = getLocalDomEventPosition_1.default(mouseEvent, topElement);
                user.mouse.x = pos.x;
                user.mouse.y = pos.y;
            }
        };
        var setTouches = function (touchEvent) {
            user.touches.splice(0);
            // Since the mount itself might be subject to sizing styles that we cannot
            // use to calculate appropriately, use the top element i.e. the 'artboard'
            var topElement = _this.mount.childNodes[0];
            if (topElement) {
                for (var i = 0; i < touchEvent.touches.length; i++) {
                    var touch = touchEvent.touches[i];
                    var pos = getLocalDomEventPosition_1.default(touch, topElement);
                    user.touches.push(pos);
                }
            }
        };
        var setMouches = function () {
            user.mouches.splice(0);
            // Only treat a mouse like a touch if it is down.
            if (user.mouse.down) {
                user.mouches.push(user.mouse);
            }
            user.mouches.push.apply(user.mouches, user.touches);
        };
        var clearKey = function () {
            for (var which in user.keys) {
                user.keys[which] = 0;
            }
        };
        var clearMouse = function () {
            user.mouse.down = 0;
            user.touches.splice(0);
            for (var i = 0; i < user.mouse.buttons.length; i++) {
                user.mouse.buttons[i] = 0;
            }
        };
        var clearMouch = function () {
            user.mouches.splice(0);
        };
        var clearTouch = function () {
            user.touches.splice(0);
        };
        var doc = this.getDocument();
        var win = this.getWindow();
        this.mount.addEventListener('mousedown', function (mouseEvent) {
            ++user.mouse.down;
            ++user.mouse.buttons[mouseEvent.button];
            setMouse(mouseEvent);
            setMouches();
        });
        this.mount.addEventListener('mouseup', function (mouseEvent) {
            clearMouse();
            clearMouch();
            setMouches();
        });
        var lastMoveTarget;
        // NOTE: if there are perf or interop issues that arise from
        //       attaching event listeners directly to host window,
        //       could expose a haikuOption for reverting to "attach to mount" behavior
        win.addEventListener('mousemove', function (mouseEvent) {
            setMouse(mouseEvent);
            setMouches();
            if (lastMoveTarget !== mouseEvent.target) {
                lastMoveTarget = mouseEvent.target;
                var moveElement = void 0;
                // If the move has taken us outside of our component, use the mount
                if (_this.mount.contains(mouseEvent.target)) {
                    moveElement = _this.getHaikuElementFromTarget(mouseEvent.target);
                }
                else {
                    moveElement = _this.getHaikuElementFromTarget(_this.mount);
                }
                if (moveElement) {
                    moveElement.triggerHover(mouseEvent);
                }
            }
        });
        win.addEventListener('mouseenter', function (mouseEvent) {
            clearMouse();
            clearMouch();
        });
        win.addEventListener('mouseleave', function (mouseEvent) {
            clearMouse();
            clearMouch();
        });
        this.mount.addEventListener('wheel', function (mouseEvent) {
            setMouse(mouseEvent);
            setMouches();
        }, {
            passive: true,
        });
        doc.addEventListener('keydown', function (keyEvent) {
            if (user.keys[keyEvent.which] === undefined) {
                user.keys[keyEvent.which] = 0;
            }
            ++user.keys[keyEvent.which];
        });
        doc.addEventListener('keyup', function (keyEvent) {
            if (user.keys[keyEvent.which] === undefined) {
                user.keys[keyEvent.which] = 0;
            }
            // Known Mac "feature" where keyup never fires while meta key (91) is down
            // When right-click menu is toggled we don't get all mouseup events
            if (keyEvent.which === 91 || keyEvent.which === 17) {
                clearKey();
            }
            user.keys[keyEvent.which] = 0;
        });
        // If there's any sizing mode that requires computation of container size
        // and alwaysComputeSizing is *disabled*, make an "overriding" assumption
        // that we probably want to recompute the container when media queries change.
        if (this.hasSizing() && !this.config.alwaysComputeSizing) {
            win.addEventListener('resize', function () {
                _this.shouldCreateContainer = true;
            });
            win.addEventListener('orientationchange', function () {
                _this.shouldCreateContainer = true;
            });
        }
        win.addEventListener('blur', function (blurEvent) {
            clearKey();
            clearMouse();
            clearTouch();
            clearMouch();
        });
        win.addEventListener('focus', function (blurEvent) {
            clearKey();
            clearMouse();
            clearTouch();
            clearMouch();
        });
        win.addEventListener('touchstart', function (touchEvent) {
            setTouches(touchEvent);
            setMouches();
        }, {
            passive: true,
        });
        win.addEventListener('touchend', function (touchEvent) {
            clearTouch();
            clearMouch();
        });
        win.addEventListener('touchmove', function (touchEvent) {
            setTouches(touchEvent);
            setMouches();
        }, {
            passive: true,
        });
        win.addEventListener('touchenter', function (touchEvent) {
            clearTouch();
            clearMouch();
        });
        win.addEventListener('touchleave', function (touchEvent) {
            clearTouch();
            clearMouch();
        });
    };
    HaikuDOMRenderer.prototype.decideMountElement = function (component, selector, name) {
        // For keyboard events, if subscribed to the component, and if the component is the runtime root,
        // we automatically attach its handler to window, as this is the 98%-case desired behavior
        if (name === 'keyup' || name === 'keydown' || name === 'keypress') {
            if (!component.host && "haiku:" + component.getComponentId() === selector) {
                var win = this.getWindow();
                return win;
            }
        }
        // Otherwise, fallthrough and assume we want to listen to our own mount element
        return this.mount;
    };
    HaikuDOMRenderer.prototype.mountEventListener = function (component, selector, name, listener) {
        var _this = this;
        var rewritten = name;
        if (name === 'mouseenter') {
            rewritten = 'mouseover';
        }
        else if (name === 'mouseleave') {
            rewritten = 'mouseout';
        }
        // Convert haiku:* selectors into proper attribute selectors
        var query = selector;
        if (selector.slice(0, 6) === 'haiku:') {
            query = "[haiku-id=\"" + selector.slice(6) + "\"]";
        }
        var mount = this.decideMountElement(component, selector, name);
        // Since elements inside out tree may be added or removed at will, event listener
        // management (i.e. cleanup and re-registration) becomes a problem. Rather than solve
        // that tangle, we register listeners on our mount element, which is assumed to
        // remain through the lifespan of the component, and then delegate the events as
        // appropriate per their respective specifications.
        mount.addEventListener(rewritten, function (domEvent) {
            // If no explicit selector/target for the event, just fire the listener
            if (!selector || selector === HaikuBase_1.GLOBAL_LISTENER_KEY ||
                !domEvent || !domEvent.target) {
                listener(null, _this.wrapEvent(name, domEvent, null, component));
                return;
            }
            // If no queryable node has been rendered, we can't perform a match
            if (!component.target || !component.target.parentNode) {
                return;
            }
            // If the event originated from the element or its descendants
            var match = component.target.parentNode.querySelector(query);
            if (match) {
                if (_this.shouldListenerReceiveEvent(name, rewritten, domEvent, match, mount)) {
                    listener(_this.getHaikuElementFromTarget(match), domEvent.target, _this.wrapEvent(name, domEvent, match, component));
                    return;
                }
            }
        });
    };
    HaikuDOMRenderer.prototype.getHaikuElementFromTarget = function (target) {
        return (target &&
            target.haiku &&
            target.haiku.element &&
            target.haiku.element.__memory &&
            target.haiku.element.__memory.element);
    };
    /**
     * @description An opportunity to return an event aligned with our own API semantics.
     * Keep in mind that the three elements involved here may be different:
     *   this.mount - the host node for the component, the node we actually attach listeners to.
     *   event.target - the element on which the event actually originated
     *   elementListenedTo - the element that the user is listening to the event on
     */
    HaikuDOMRenderer.prototype.wrapEvent = function (eventName, nativeEvent, elementListenedTo, hostComponent) {
        return nativeEvent;
    };
    HaikuDOMRenderer.prototype.getUser = function () {
        var zoom = this.getZoom();
        var pan = this.getPan();
        return {
            zoom: zoom,
            pan: pan,
            mouse: {
                x: (this.user.mouse.x) / zoom,
                y: (this.user.mouse.y) / zoom,
                z: 0,
                down: this.user.mouse.down,
                buttons: this.user.mouse.buttons.slice(),
            },
            keys: __assign({}, this.user.keys),
            touches: this.user.touches.slice(),
            mouches: this.user.mouches.slice(),
        };
    };
    HaikuDOMRenderer.createTagNode = function (domElement, virtualElement, parentVirtualElement, component) {
        var tagName = normalizeName_1.default(getTypeAsString_1.default(virtualElement));
        var compositeId = HaikuComponent_1.getNodeCompositeId(virtualElement);
        var newDomElement;
        if (SVG_ELEMENT_NAMES[tagName]) {
            // SVG
            newDomElement = createSvgElement_1.default(domElement, tagName);
        }
        else {
            // Normal DOM
            newDomElement = domElement.ownerDocument.createElement(tagName);
        }
        // This didn't happen in renderTree because the element didn't exist yet.
        if (!newDomElement.haiku) {
            newDomElement.haiku = {
                // This is used to detect whether the element's host component has changed.
                // Don't remove this without understanding the effect on Haiku.app.
                component: component,
                explicitStyles: {},
            };
        }
        component.subcacheEnsure(compositeId);
        var incomingKey = virtualElement.key ||
            (virtualElement.attributes && virtualElement.attributes.key);
        if (incomingKey !== undefined && incomingKey !== null) {
            newDomElement.haiku.key = incomingKey;
        }
        // updateElement recurses down into setAttributes, etc.
        HaikuDOMRenderer.updateElement(newDomElement, virtualElement, domElement, parentVirtualElement, component, null);
        return newDomElement;
    };
    HaikuDOMRenderer.appendChild = function (alreadyChildElement, virtualElement, parentDomElement, parentVirtualElement, component) {
        var domElementToInsert = isTextNode_1.default(virtualElement)
            ? createTextNode_1.default(parentDomElement, virtualElement)
            : HaikuDOMRenderer.createTagNode(parentDomElement, virtualElement, parentVirtualElement, component);
        applyLayout_1.default(domElementToInsert, virtualElement, component);
        parentDomElement.appendChild(domElementToInsert);
        return domElementToInsert;
    };
    HaikuDOMRenderer.replaceElement = function (domElement, virtualElement, parentDomNode, parentVirtualElement, component) {
        var compositeId = HaikuComponent_1.getNodeCompositeId(virtualElement);
        component.subcacheClear(compositeId);
        var newElement = isTextNode_1.default(virtualElement)
            ? createTextNode_1.default(domElement, virtualElement)
            : HaikuDOMRenderer.createTagNode(domElement, virtualElement, parentVirtualElement, component);
        applyLayout_1.default(newElement, virtualElement, component);
        parentDomNode.replaceChild(newElement, domElement);
        return newElement;
    };
    HaikuDOMRenderer.updateElement = function (domElement, virtualElement, parentNode, parentVirtualElement, component, isPatchOperation) {
        var compositeId = HaikuComponent_1.getNodeCompositeId(virtualElement);
        // If a text node, go straight to 'replace' since we don't know the tag name
        if (isTextNode_1.default(virtualElement)) {
            replaceElementWithText_1.default(domElement, virtualElement, component);
            return virtualElement;
        }
        if (!domElement.haiku) {
            domElement.haiku = {
                // This is used to detect whether the element's host component has changed.
                // Don't remove this without understanding the effect on Haiku.app.
                component: component,
                explicitStyles: {},
            };
        }
        component.subcacheEnsure(compositeId);
        if (!domElement.haiku.element) {
            // Must clone so we get a correct picture of differences in attributes between runs, e.g. for detecting attribute
            // removals
            domElement.haiku.element = HaikuDOMRenderer.cloneVirtualElement(virtualElement);
        }
        var domTagName = domElement.tagName.toLowerCase().trim();
        var elName = normalizeName_1.default(getTypeAsString_1.default(virtualElement));
        var virtualElementTagName = elName.toLowerCase().trim();
        var incomingKey = virtualElement.key || (virtualElement.attributes && virtualElement.attributes.key);
        var existingKey = domElement.haiku && domElement.haiku.key;
        var isKeyDifferent = incomingKey !== null && incomingKey !== undefined && incomingKey !== existingKey;
        // For so-called 'horizon' elements, we assume that we've ceded control to another renderer,
        // so the most we want to do is update the attributes and layout properties, but leave the rest alone
        if (!component.isHorizonElement(virtualElement)) {
            if (domTagName !== virtualElementTagName) {
                return HaikuDOMRenderer.replaceElement(domElement, virtualElement, parentNode, parentVirtualElement, component);
            }
            if (isKeyDifferent) {
                return HaikuDOMRenderer.replaceElement(domElement, virtualElement, parentNode, parentVirtualElement, component);
            }
        }
        if (virtualElement.attributes && typeof virtualElement.attributes === 'object') {
            assignAttributes_1.default(domElement, virtualElement, component, isPatchOperation);
        }
        applyLayout_1.default(domElement, virtualElement, component);
        if (incomingKey !== undefined && incomingKey !== null) {
            domElement.haiku.key = incomingKey;
        }
        var instance = (virtualElement &&
            virtualElement.__memory &&
            virtualElement.__memory.instance) || component;
        var children = (virtualElement.__memory && virtualElement.__memory.children) || virtualElement.children;
        if (Array.isArray(children)) {
            // For performance, we don't render children during a patch operation, except in the case
            // that we have some text content, which we (hack) need to always assume needs an update.
            // TODO: Fix this hack and make smarter
            var doSkipChildren = (isPatchOperation &&
                children[0] instanceof Object);
            HaikuDOMRenderer.renderTree(domElement, virtualElement, children, instance, isPatchOperation, doSkipChildren);
        }
        else if (!children) {
            // In case of falsy virtual children, we still need to remove elements that were already there
            HaikuDOMRenderer.renderTree(domElement, virtualElement, [], instance, isPatchOperation, null);
        }
        return domElement;
    };
    HaikuDOMRenderer.renderTree = function (domElement, virtualElement, virtualChildren, component, isPatchOperation, doSkipChildren) {
        connectTarget(virtualElement, domElement);
        var compositeId = HaikuComponent_1.getNodeCompositeId(virtualElement);
        if (!domElement.haiku) {
            domElement.haiku = {
                // This is used to detect whether the element's host component has changed.
                // Don't remove this without understanding the effect on Haiku.app.
                component: component,
                explicitStyles: {},
            };
        }
        domElement.haiku.virtual = virtualElement;
        // Must clone so we get a correct picture of differences in attributes
        // between runs, e.g. for detecting attribute removals
        domElement.haiku.element = HaikuDOMRenderer.cloneVirtualElement(virtualElement);
        component.subcacheEnsure(compositeId);
        if (!Array.isArray(virtualChildren)) {
            return domElement;
        }
        // For so-called 'horizon' elements, we assume that we've ceded control to another renderer,
        // so the most we want to do is update the attributes and layout properties, but leave the rest alone
        if (component.isHorizonElement(virtualElement)) {
            return domElement;
        }
        // During patch renders we don't want to drill down and update children as
        // we're just going to end up doing a lot of unnecessary DOM writes
        if (doSkipChildren) {
            return domElement;
        }
        while (virtualChildren.length > 0 && isBlankString_1.default(virtualChildren[0])) {
            virtualChildren.shift();
        }
        // Store a copy of the array here, otherwise we can hit a race where as we remove
        // elements from the DOM, the childNodes array gets shifted and the indices get offset, leading
        // to removals not occurring properly
        var domChildNodes = [];
        for (var k = 0; k < domElement.childNodes.length; k++) {
            domChildNodes[k] = domElement.childNodes[k];
        }
        var max = virtualChildren.length;
        if (max < domChildNodes.length) {
            max = domChildNodes.length;
        }
        for (var i = 0; i < max; i++) {
            var virtualChild = virtualChildren[i];
            var domChild = domChildNodes[i];
            if (isNil(virtualChild) && !domChild) {
                // empty
            }
            else if (isNil(virtualChild) && domChild) {
                removeElement_1.default(domChild, compositeId, component);
            }
            else {
                if (!domChild) {
                    var insertedElement = HaikuDOMRenderer.appendChild(null, virtualChild, domElement, virtualElement, component);
                    connectTarget(virtualChild, insertedElement);
                }
                else {
                    // Circumstances in which we want to completely *replace* the element:
                    // - We see that our cached target element is not the one at this location
                    // - We see that the DOM id doesn't match the incoming one
                    // - we see that the haiku-id doesn't match the incoming one.
                    // If we now have an element that is different, we need to trigger a full re-render
                    // of itself and all of its children, because e.g. url(#...) references will retain pointers to
                    // old elements and this is the only way to clear the DOM to get a correct render.
                    var shouldReplace = HaikuDOMRenderer.shouldElementBeReplaced(domChild, virtualChild, component);
                    if (shouldReplace) {
                        var newElement = HaikuDOMRenderer.replaceElement(domChild, virtualChild, domElement, virtualElement, component);
                        connectTarget(virtualChild, newElement);
                    }
                    else {
                        HaikuDOMRenderer.updateElement(domChild, virtualChild, domElement, virtualElement, component, isPatchOperation);
                        connectTarget(virtualChild, domChild);
                    }
                }
            }
        }
        return domElement;
    };
    HaikuDOMRenderer.shouldElementBeReplaced = function (domElement, virtualElement, component) {
        if (domElement.haiku) {
            var compositeIdNew = HaikuComponent_1.getNodeCompositeId(virtualElement);
            var compositeIdOld = HaikuComponent_1.getNodeCompositeId(domElement.haiku.element);
            if (compositeIdNew !== compositeIdOld) {
                return true;
            }
            if (domElement.haiku.component) {
                // If the element carried at this node has a different host component,
                // we should do a full replacement, since the cache of the two instances
                // are different and may result in different (cached) rendering output
                if (domElement.haiku.component !== component) {
                    return true;
                }
            }
        }
        return false;
    };
    HaikuDOMRenderer.cloneAttributes = function (attributes) {
        if (!attributes) {
            return {};
        }
        var clone = {};
        for (var key in attributes) {
            clone[key] = attributes[key];
        }
        return clone;
    };
    HaikuDOMRenderer.cloneVirtualElement = function (virtualElement) {
        return {
            elementName: virtualElement.elementName,
            attributes: HaikuDOMRenderer.cloneAttributes(virtualElement.attributes),
            children: (virtualElement.__memory && virtualElement.__memory.children) || virtualElement.children,
            __memory: virtualElement.__memory,
        };
    };
    HaikuDOMRenderer.__name__ = 'HaikuDOMRenderer';
    return HaikuDOMRenderer;
}(HaikuBase_1.default));
exports.default = HaikuDOMRenderer;
var SVG_ELEMENT_NAMES = {
    a: true,
    altGlyph: true,
    altGlyphDef: true,
    altGlyphItem: true,
    animate: true,
    animateColor: true,
    animateMotion: true,
    animateTransform: true,
    circle: true,
    clipPath: true,
    'color-profile': true,
    cursor: true,
    defs: true,
    desc: true,
    discard: true,
    ellipse: true,
    feBlend: true,
    feColorMatrix: true,
    feComponentTransfer: true,
    feComposite: true,
    feConvolveMatrix: true,
    feDiffuseLighting: true,
    feDisplacementMap: true,
    feDistantLight: true,
    feFlood: true,
    feFuncA: true,
    feFuncB: true,
    feFuncG: true,
    feFuncR: true,
    feGaussianBlur: true,
    feImage: true,
    feMerge: true,
    feMergeNode: true,
    feMorphology: true,
    feOffset: true,
    fePointLight: true,
    feSpecularLighting: true,
    feSpotLight: true,
    feTile: true,
    feTurbulence: true,
    filter: true,
    font: true,
    'font-face': true,
    'font-face-format': true,
    'font-face-name': true,
    'font-face-src': true,
    'font-face-uri': true,
    foreignObject: true,
    g: true,
    glyph: true,
    glyphRef: true,
    hkern: true,
    image: true,
    line: true,
    linearGradient: true,
    marker: true,
    mask: true,
    metadata: true,
    'missing-glyph': true,
    mpath: true,
    path: true,
    pattern: true,
    polygon: true,
    polyline: true,
    radialGradient: true,
    rect: true,
    script: true,
    set: true,
    stop: true,
    style: true,
    svg: true,
    switch: true,
    symbol: true,
    text: true,
    textPath: true,
    title: true,
    tref: true,
    tspan: true,
    use: true,
    view: true,
    vkern: true,
};
/* tslint:disable */
var mixpanelSnippetInjector = new Function("\n  (function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+\"=([^&]*)\")))?l[1]:null};g&&c(g,\"state\")&&(i=JSON.parse(decodeURIComponent(c(g,\"state\"))),\"mpeditor\"===i.action&&(b.sessionStorage.setItem(\"_mpcehash\",g),history.replaceState(i.desiredHash||\"\",e.title,j.pathname+j.search)))}catch(m){}var k,h;window['mixpanel']=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(\".\");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,\n  0)))}}var d=a;\"undefined\"!==typeof f?d=a[f]=[]:f=\"mixpanel\";d.people=d.people||[];d.toString=function(b){var a=\"mixpanel\";\"mixpanel\"!==f&&(a+=\".\"+f);b||(a+=\" (stub)\");return a};d.people.toString=function(){return d.toString(1)+\".people (stub)\"};k=\"disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user\".split(\" \");\n  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;}})(document,window.mixpanel||[]);\n");
var mixpanelInit = function (mixpanelToken, component) {
    // Only initialize Mixpanel if we're running in the browser
    if (typeof window !== 'undefined') {
        // Don't initialize multiple times if multiple components are on the page
        if (!window.mixpanel) {
            mixpanelSnippetInjector();
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.async = true;
            script.type = 'text/javascript';
            script.src = 'https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js';
            head.appendChild(script);
            window.mixpanel.init(mixpanelToken, { ip: false });
        }
        var metadata = (component.bytecode && component.bytecode.metadata) || {};
        window.mixpanel.track('component:initialize', assign_1.default({
            platform: 'dom',
        }, metadata));
    }
};
//# sourceMappingURL=HaikuDOMRenderer.js.map