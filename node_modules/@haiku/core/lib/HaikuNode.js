"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Layout3D_1 = require("./Layout3D");
var array_unique_1 = require("./vendor/array-unique");
var uniq = array_unique_1.default.uniq;
var ALT_CLASS_NAME_ATTR = 'className'; // Ease of React integration
var ATTR_EXEC_RE = /\[([a-zA-Z0-9]+)([$|^~])?(=)?"?(.+?)?"?( i)?]/;
var ATTR_PREFIX = '[';
var CLASS_NAME_ATTR = 'class';
var CLASS_PREFIX = '.';
var FUNCTION = 'function';
var HAIKU_ID_ATTRIBUTE = 'haiku-id';
var HAIKU_PREFIX = 'haiku:';
var ID_PREFIX = '#';
var PIECE_SEPARATOR = ',';
var SPACE = ' ';
var getFnName = function (fn) {
    if (fn.name) {
        return fn.name;
    }
    var str = fn.toString();
    //                  | | <-- this space is always here via toString()
    var reg = /function ([^(]*)/;
    var ex = reg.exec(str);
    return ex && ex[1];
};
exports.parseAttrSelector = function (selector) {
    var matches = ATTR_EXEC_RE.exec(selector);
    if (!matches) {
        return null;
    }
    return {
        key: matches[1],
        operator: matches[3] && (matches[2] || '') + matches[3],
        value: matches[4],
        insensitive: !!matches[5],
    };
};
exports.cssMatchByAttribute = function (node, attrKeyToMatch, attrOperator, attrValueToMatch, options) {
    var attributes = node[options.attributes];
    if (attributes) {
        var attrValue = attributes[attrKeyToMatch];
        // If no operator, do a simple presence check ([foo])
        if (!attrOperator) {
            return !!attrValue;
        }
        switch (attrOperator) {
            case '=':
                return attrValueToMatch === attrValue;
            // case '~=':
            // case '|=':
            // case '^=':
            // case '$=':
            // case '*=':
            default:
                console.warn('Operator `' + attrOperator + '` not supported yet');
                return false;
        }
    }
};
exports.cssMatchByClass = function (node, className, options) {
    var attributes = node[options.attributes];
    if (attributes) {
        var foundClassName = attributes[CLASS_NAME_ATTR];
        if (!foundClassName) {
            foundClassName = attributes[ALT_CLASS_NAME_ATTR];
        }
        if (foundClassName) {
            var classPieces = foundClassName.split(SPACE);
            if (classPieces.indexOf(className) !== -1) {
                return true;
            }
        }
    }
};
exports.cssMatchByHaiku = function (node, haikuString, options) {
    var attributes = node[options.attributes];
    if (!attributes) {
        return false;
    }
    if (!attributes[HAIKU_ID_ATTRIBUTE]) {
        return false;
    }
    return attributes[HAIKU_ID_ATTRIBUTE] === haikuString;
};
exports.cssMatchById = function (node, id, options) {
    var attributes = node[options.attributes];
    if (attributes) {
        if (attributes.id === id) {
            return true;
        }
    }
};
exports.cssMatchByTagName = function (node, tagName, options) {
    var val = node[options.name];
    if (val) {
        if (typeof val === 'string' && val === tagName) {
            return true;
        }
        if (typeof val === FUNCTION) {
            // Allow function constructors to act as the tag name
            if (getFnName(val) === tagName) {
                return true;
            }
        }
        if (typeof val === 'object') {
            // Allow for things like instances to act as the tag name
            if (val.name === tagName || val.tagName === tagName) {
                return true;
            }
        }
    }
};
exports.cssMatchOne = function (node, piece, options) {
    if (piece.slice(0, 6) === HAIKU_PREFIX) {
        return exports.cssMatchByHaiku(node, piece.slice(6), options);
    }
    if (piece[0] === ID_PREFIX) {
        return exports.cssMatchById(node, piece.slice(1, piece.length), options);
    }
    if (piece[0] === CLASS_PREFIX) {
        return exports.cssMatchByClass(node, piece.slice(1, piece.length), options);
    }
    if (piece[0] === ATTR_PREFIX) {
        var parsedAttr = exports.parseAttrSelector(piece);
        if (!parsedAttr) {
            return false;
        }
        return exports.cssMatchByAttribute(node, parsedAttr.key, parsedAttr.operator, parsedAttr.value, options);
    }
    return exports.cssMatchByTagName(node, piece, options);
};
exports.cssQueryList = function (list, query, options) {
    var matches = [];
    var pieces = query.split(PIECE_SEPARATOR);
    for (var i = 0; i < pieces.length; i++) {
        var piece = pieces[i].trim();
        for (var j = 0; j < list.length; j++) {
            var node = list[j];
            if (exports.cssMatchOne(node, piece, options)) {
                matches.push(node);
            }
        }
    }
    return matches;
};
exports.cssQueryTree = function (node, query, options) {
    if (!node || typeof node !== 'object') {
        return [];
    }
    return exports.cssQueryList(exports.manaFlattenTree(node, options), query, options);
};
exports.manaFlattenTree = function (node, options, unique, list, depth, index) {
    if (unique === void 0) { unique = true; }
    if (list === void 0) { list = []; }
    if (depth === void 0) { depth = 0; }
    if (index === void 0) { index = 0; }
    list.push(node);
    // Don't recurse down into the children of nested components, which should be 'invisible' to us.
    // Nested components are indicated when their name is not a string, e.g. a component descriptor.
    if (depth < 1 || typeof node[options.name] === 'string') {
        var children = node[options.children];
        if (!children || typeof children === 'string') {
            return list;
        }
        if (Array.isArray(children)) {
            var copies = children.slice(0);
            // Without this, we'll have an infinite loop since the source child appears in both the
            // original children and the snapshotted children arrays.
            uniq(copies);
            for (var i = 0; i < copies.length; i++) {
                exports.manaFlattenTree(copies[i], options, false, list, depth + 1, i);
            }
        }
        else if (typeof children === 'object') {
            list.push(children);
            return list;
        }
    }
    return unique ? uniq(list) : list;
};
exports.visitManaTree = function (locator, mana, visitor, parent, index) {
    if (!mana || typeof mana === 'string') {
        return null;
    }
    visitor(mana.elementName, mana.attributes, mana.children, mana, locator, parent, index);
    if (!mana.children) {
        return null;
    }
    for (var i = 0; i < mana.children.length; i++) {
        var child = mana.children[i];
        exports.visitManaTree(locator + '.' + i, child, visitor, mana, i);
    }
};
exports.visit = function (mana, visitor, parent) {
    if (!mana || typeof mana !== 'object') {
        return;
    }
    visitor(mana, parent);
    var children = ((mana.__memory && mana.__memory.children) || mana.children);
    if (children) {
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child && child.__memory && child.__memory.instance) {
                continue;
            }
            exports.visit(child, visitor, mana);
        }
    }
};
exports.ascend = function (mana, ascender) {
    if (!mana || typeof mana !== 'object') {
        return;
    }
    ascender(mana);
    if (mana.__memory) {
        // Don't ascend beyond the scope of the host component instance
        if (!mana.__memory.instance && mana.__memory.parent) {
            exports.ascend(mana.__memory.parent, ascender);
        }
    }
};
exports.cloneNodeShallow = function (node) {
    if (!node) {
        return node;
    }
    return __assign({}, node, { attributes: exports.cloneAttributes(node.attributes), layout: Layout3D_1.default.clone(node.layout) });
};
exports.cloneAttributes = function (attributes) {
    if (!attributes) {
        return attributes;
    }
    var out = __assign({}, attributes);
    if (attributes.style) {
        out.style = Object.assign({}, attributes.style);
    }
    return out;
};
//# sourceMappingURL=HaikuNode.js.map