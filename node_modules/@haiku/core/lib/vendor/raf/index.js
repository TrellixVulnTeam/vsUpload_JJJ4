"use strict";
/* tslint:disable */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The MIT License
 *
 * Copyright (c) 2017 Chris Dickinson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
var performance_now_1 = require("../performance-now");
var root = typeof window === 'undefined' ? global : window;
var vendors = ['moz', 'webkit'];
var suffix = 'AnimationFrame';
var raf;
var caf;
if (typeof window !== 'undefined') {
    raf = window['request' + suffix];
    caf = window['cancel' + suffix] || window['cancelRequest' + suffix];
    for (var i = 0; !raf && i < vendors.length; i++) {
        raf = window[vendors[i] + 'Request' + suffix];
        caf =
            window[vendors[i] + 'Cancel' + suffix] ||
                window[vendors[i] + 'CancelRequest' + suffix];
    }
    // Some versions of FF have rAF but not cAF
    if (!raf || !caf) {
        var last_1 = 0, id_1 = 0, queue_1 = [], frameDuration_1 = 1000 / 60;
        raf = function (callback) {
            if (queue_1.length === 0) {
                var _now = performance_now_1.default(), next = Math.max(0, frameDuration_1 - (_now - last_1));
                last_1 = next + _now;
                setTimeout(function () {
                    var cp = queue_1.slice(0);
                    // Clear queue here to prevent
                    // callbacks from appending listeners
                    // to the current frame's queue
                    queue_1.length = 0;
                    for (var i = 0; i < cp.length; i++) {
                        if (!cp[i].cancelled) {
                            try {
                                cp[i].callback(last_1);
                            }
                            catch (e) {
                                setTimeout(function () {
                                    throw e;
                                }, 0);
                            }
                        }
                    }
                }, Math.round(next));
            }
            queue_1.push({
                handle: ++id_1,
                callback: callback,
                cancelled: false,
            });
            return id_1;
        };
        caf = function (handle) {
            for (var i = 0; i < queue_1.length; i++) {
                if (queue_1[i].handle === handle) {
                    queue_1[i].cancelled = true;
                }
            }
        };
    }
}
else {
    // Turn raf and caf into noops outside of the web.
    // This should help with leaked handles/isomorphic rendering.
    raf = caf = function () { };
}
function rafCall(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn);
}
function cafCall() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return caf.apply(root, args);
}
exports.default = {
    request: rafCall,
    cancel: cafCall,
};
//# sourceMappingURL=index.js.map