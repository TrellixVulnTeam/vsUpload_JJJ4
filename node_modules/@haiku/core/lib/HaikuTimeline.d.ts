/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
import { IHaikuComponent } from './api';
import HaikuBase from './HaikuBase';
export declare const enum TimeUnit {
    Millisecond = "ms",
    Frame = "fr"
}
export declare const enum PlaybackFlag {
    ONCE = "once",
    PLAY = "play",
    LOOP = "loop",
    STOP = "stop",
    SEEK = "seek"
}
export default class HaikuTimeline extends HaikuBase {
    options: any;
    component: IHaikuComponent;
    name: any;
    private globalClockTime;
    private localElapsedTime;
    private localControlledTime;
    private areUpdatesFrozen;
    private isTimelinePlaying;
    private isTimelineLooping;
    private offsetCalculator;
    private lastFrame;
    private numLoops;
    constructor(component: IHaikuComponent, name: any, options: any);
    getMs(amount: number, unit: TimeUnit): number;
    getFrameDuration(): number;
    assignOptions(options: any): void;
    ensureClockIsRunning(): void;
    /**
     * @method setComponent
     * @description Internal hook to allow Haiku to hot swap on-stage components during editing.
     */
    setComponent(component: any): void;
    doUpdateWithGlobalClockTime(globalClockTime: any): void;
    doUpdateWithTimeDelta(deltaClockTime: any): void;
    executePreUpdateHooks(globalClockTime: number): void;
    executePostUpdateHooks(globalClockTime: number): void;
    getLastFrame(): number;
    controlTime(controlledTimeToSet: any, newGlobalClockTime: any): void;
    isTimeControlled(): boolean;
    /**
     * @method getName
     * @description Return the name of this timeline
     */
    getName(): any;
    /**
     * @method getMaxTime
     * @description Return the maximum time that this timeline will reach, in ms.
     */
    getMaxTime(): number;
    getMaxKeyframeTime(): number;
    getMaxActionsTime(): number;
    getDescriptor(): import("./api").BytecodeTimeline;
    /**
     * @description The millisecond value for the beginning of one frame past the max.
     */
    getCeilTime(): number;
    /**
     * @method getClockTime
     * @description fseek the global clock time that this timeline is at, in ms,
     * whether or not our local time matches it or it has exceeded our max.
     * This value is ultimately managed by the clock and passed in.
     */
    getClockTime(): number;
    /**
     * @method getElapsedTime
     * @description Return the amount of time that has elapsed on this timeline since
     * it started updating, up to the most recent time update it received from the clock.
     * Note that for inactive ftimelines, this value will cease increasing as of the last update.
     */
    getElapsedTime(): number;
    setElapsedTime(t: number): void;
    /**
     * @description If time has been explicitly set here via time control, this value will
     * be the number of that setting.
     */
    getControlledTime(): number;
    setControlledTime(t: number | null): void;
    /**
     * @description Return the locally elapsed time, or the maximum time of this timeline,
     * whichever is smaller. Useful if you want to know what the "effective" time of this
     * timeline is, not necessarily how much has elapsed in an absolute sense. This is used
     * in the renderer to determine what value to calculate "now" deterministically.
     */
    getBoundedTime(): number;
    /**
     * @description Convenience wrapper. Currently returns the bounded time. There's an argument
     * that this should return the elapsed time, though. #TODO
     */
    getTime(): number;
    /**
     * @description Return the current frame up to the maximum frame available for this timeline's duration.
     */
    getBoundedFrame(): number;
    /**
     * @method getUnboundedFrame
     * @description Return the current frame, even if it is above the maximum frame.
     */
    getUnboundedFrame(): number;
    /**
     * @method getFrame
     * @description Return the bounded frame.
     * There's an argument that this should return the absolute frame. #TODO
     */
    getFrame(): number;
    /**
     * @method isPlaying
     * @description Returns T/F if the timeline is playing
     */
    isPlaying(): boolean;
    setPlaying(isPlaying?: boolean): void;
    isPaused(): boolean;
    /**
     * @method isFinished
     * @description Returns T/F if the timeline is finished.
     * If this timeline is set to loop, it is never "finished".
     */
    isFinished(): boolean;
    isUnfinished(): boolean;
    getDuration(): number;
    setRepeat(bool?: boolean): void;
    getRepeat(): boolean;
    isRepeating(): boolean;
    isLooping(): boolean;
    /**
     * @method isFrozen
     * @description Returns T/F if the timeline is frozen
     */
    isFrozen(): boolean;
    freeze(): void;
    unfreeze(): void;
    start(): void;
    startSoftly(maybeElapsedTime: number): void;
    stop(): void;
    stopSoftly(): void;
    pause(): void;
    pauseSoftly(): void;
    play(options?: any): void;
    playSoftly(): void;
    seek(amount: number, unit?: TimeUnit): void;
    seekSoftly(ms: number): void;
    gotoAndPlay(amount: number, unit?: TimeUnit): void;
    gotoAndStop(amount: number, unit?: TimeUnit): void;
    setPlaybackStatus(input: any): void;
    parsePlaybackStatus(input: any): any;
    /**
     * @deprecated
     * TODO: Please change this to a getter.
     */
    duration(): number;
    readonly repeat: boolean;
    readonly time: number;
    readonly max: number;
    readonly frame: number;
    static __name__: string;
    static all: () => HaikuTimeline[];
    static where: (criteria: any) => HaikuTimeline[];
    static create: (component: IHaikuComponent, name: any, config: any) => HaikuTimeline;
    /**
     * @description Modulus, but returns zero if the second number is zero,
     * and calculates an appropriate "cycle" if the number is negative.
     */
    static modulo: (n: number, ceil: number) => number;
    /**
     * @description Given a previous elapsed time (a), a new elapsed time (b), and a max
     * time (max), determine whether the given timeline has looped between (a) and (b).
     *
     * E.g.:
     *   0----------100
     *        62        103  true
     *
     *   0----------100
     *        62    100  true
     *
     *   0----------100
     *        62   99  false
     *
     *   0----------100
     *              100  110  false
     *
     *   0----------100
     *               101  110  false
     *
     *   0----------100
     *              100
     *              100  false
     *
     *   0----------100
     *   0          100  false
     *
     *   0----------100
     *   0
     *   0  false
     */
    static didTimeLoop: (a: number, b: number, ceil: number) => boolean;
}
